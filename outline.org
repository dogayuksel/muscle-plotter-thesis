:SETUP:
#+OPTIONS: toc:nil date:nil title:nil
#+LATEX_CLASS: koma-book
#+LATEX_CLASS_OPTIONS: [a4paper, 12pt, twoside, BCOR5mm]
#+LATEX_HEADER: \usepackage[hmarginratio=1:1]{geometry}
#+LATEX_HEADER: \usepackage{mathptmx}
#+LATEX_HEADER: \usepackage[scaled=.90]{helvet}
#+LATEX_HEADER: \usepackage{courier}
#+LATEX_HEADER: \setkomafont{disposition}{\sffamily}
#+LATEX_HEADER: \setkomafont{subtitle}{\sffamily\Large}
#+LaTeX_HEADER: \usepackage[backend=bibtex,sorting=none]{biblatex}
#+LaTeX_HEADER: \addbibresource{/Users/doga/.org/bibtex/file-1.bib}
#+LATEX_HEADER: \usepackage{./source/introsections}
:END:
:VARIABLES:
#+LATEX_HEADER: \newcommand{\app}{\emph{muscle-plotter}}
#+LATEX_HEADER: \newcommand{\App}{\emph{Muscle-plotter}}
:END:
:HEADERFOOTER:
#+LATEX_HEADER: \usepackage{scrlayer-scrpage}
#+LATEX_HEADER: \ohead{Muscle-Plotter}
#+LATEX_HEADER: \ihead{Doğa Yüksel}
#+LATEX_HEADER: \ofoot[]{\thepage}
:END:
:INTRO:
#+LATEX: \frontmatter{}
#+LATEX: \begin{titlepage}
#+LATEX: \end{titlepage}
#+LATEX: \begin{hpititle}
#+LATEX: \end{hpititle}
#+LATEX: \begin{declaration}
#+LATEX: \end{declaration}
#+LATEX: \begin{abstract}
This thesis explores creating an interactive pen and paper application using Electrical Muscle Stimulation. Using this application users can input and get meaningful expressive output from a computer system in a mobile context. Using pen and paper allows the user to engage in cognitively demanding tasks, such as solving math problems. In the simplest case user inputs the a math function and later \app{} uses user's hand to plot the function. This example is further expanded into fitting lines through points, finding points of interests etc. These core components are demonstrated in six different applications from different domains.

\App{} is the first EMS system that produces spacial output, hence is more expressive then earlier systems proposed. In our user study, participants drew random plots within 4mm accuracy and preserved accuracy up to 3 cycles per cm.
#+LATEX: \end{abstract}
#+LATEX: \thispagestyle{empty}
#+LATEX: \newpage{}

#+LATEX: \renewcommand{\contentsname}{Table of Contents}
#+TOC: headlines 2
#+LATEX: \thispagestyle{empty}
#+LATEX: \newpage{}

#+LATEX: \listoffigures{}
#+LATEX: \listoftables{}
#+LATEX: \thispagestyle{empty}
#+LATEX: \newpage{}
:END:

#+LATEX: \mainmatter{}
* Introduction

  Interactive systems based on electrical muscle stimulation (EMS) actuate users by sending an electric signal to muscle fibers and motor neurons through electrodes attached to the skin. The possessed hand \cite{tamaki_possessedhand}, for example, used this technique to assist users while learning the finger poses required to play an instrument.

  #+CAPTION:    Muscle Plotter - Teaser
  #+LABEL:      fig:muscle-plotter-teaser
  #+ATTR_LaTeX: :width 132mm
  [[./images/teaser.JPG]]

  Interactive EMS systems utilize the force generated by user's own muscles. Alternative implementations require some form of scaffolding working together with a motor. Using mobility of the body allows interactive systems that can be implemented in smaller form factors. Such systems are ideal for mobile use (mobile gaming \cite{lopes_musclepropell}) as well as wearable use (pedestrian cruise control \cite{pfeiffer_cruise}). EMS systems also enable implementing input/output interactions that use the same modality (aka symmetric interaction \cite{roudaut_gesture}) by using the same gesture language for input and output (\cite{lopes_proprioceptive}). This allows creating novel interactions with user's own body parts and allow to enrich capabilities of existing objects \cite{lopes_affordance++}. 

  Unfortunately, the price for these benefits is that the interactive EMS systems presented so far lack expressiveness. Existing interactive EMS systems output a single value, such as screen tilt \cite{lopes_musclepropell} or wrist tilt \cite{lopes_proprioceptive} or one of multiple behaviors \cite{lopes_affordance++}. Since subsequent output overwrites earlier output, users can only observe a single value at a given time.

  In this paper, we explore how to create more expressive EMS-based systems. \App{} achieves this by persisting EMS output, allowing the system to build up a larger whole. More specifically, (1) muscle-plotter spreads out the 1D signal produced by EMS over a 2D surface. Rather than repeatedly updating a single value, this renders many values into curves. (2) By adding the pen, we persist this signal, allowing the system to build up a larger display, which in turn enables longer and more meaningful interactions.

** Motivation

   Pen and paper is an important activity for concerning human creativity and productivity. The medium of pen and paper is familiar for many people. Developing technologies that could enhance the capabilities of this medium can be beneficial to many. \App{} builds upon this idea and imagines possibility of a future interface without screens, an interface that could be miniaturized and integrated.

** Contribution

   \App{} extends on this line of work by providing a more expressive EMS-based system, which is attained by persisting the EMS output onto the paper. Older systems communicate via discrete poses of the users’ body, resulting with a single value any given time. \App actuates user's wrist while dragging the pen to lay down a curve. Since the curve persists on the paper, users can refer or get back to interact even after making several other interactions on the page. These characteristics lend itself to more expressive and longer interactions with the ability to communicate series of values, which later can be used to solve complex problems. 

** Thesis overview

   This thesis will continue by looking at related work in the next chapter. It will then further investigate walkthroughs of the applications developed for \app{}. In the following chapter, the implementation of \app{} is described. After implementation, a user study to understand capabilities of \app{} is presented. Last two chapters of this thesis is reserved for discussion and conclusion.


* Fundamentals and Related Work

** Fundamentals

   \App{} builds upon pen and paper interactions, activities such as writing, note taking, sketching that is essential for human intellect. These activities form the pillars for developing own ideas, communicating and building upon them. Ullman et al. have investigated how mechanical designers used drawings, and observed that it `acts as an extended memory', helps analyzing and simulating forms in return enables communication of ideas \cite{ullman_importancedrawing}.

   This thesis is further related to interactive pen-based interfaces, interactive systems based on exoskeletons or electrical muscle simulators. Following chapter will further investigate examples from the state of the art research.

** Related Work

*** Pen-based Interaction Techniques

    Interactive systems based on pen and paper has existed since the dawn of HCI. Already competent capabilities of pen and paper is further enhanced by intelligent systems and interaction techniques. Holding a pen is traditionally unimanual and that allows cooperative unimanual interactions through these interaction techniques \cite{Hinckley_coopbimanual, Guiard_asymetricbimanual}.

    Based of the principles mentioned above, interaction techniques developed of pen-based systems are as follows, canonically SketchPad \cite{sutherland_sketch}. Another example is `Teddy' which is a system that allows 3D modeling based on 2D sketching \cite{igarashi_teddy}. CrossY tackles the problem of interacting with GUI elements on a paper with a pen \cite{Apitz_crossy}. PapierCraft is another example where users can interact with the elements on paper using gestures such as pigtails, crop marks or underlines to accomplish actions such as copy & paste, linking, etc. \cite{liao_papiercraft}.

    Several other studies extend the use of pen and paper to an other domain in particular to mathematics. Flatland \cite{mynatt_flatland}, for example, is a pen-based interface for whiteboards that supports basic math and map drawing. Also, both MathPad \cite{laviola_mathpad} and Hands-on Math \cite{zeleznik_hands} are systems that provide deeper support for understanding of mathematics.

*** Haptic Output Systems

    Some researchers have taken tangible input further by using it not only for input but also for output. Notably the Actuated Workbench closed the loop for a tangible tabletop system by actuating the pucks using magnetic forces \cite{pangaro_actuated}. Another example for closing the loop comes from Gesture Output \cite{roudaut_gesture} in which the loop of touch gestures on a mobile phone is closed by actuating the user’s finger.

    Most haptic systems with sufficient force to actuate users transmit forces from a motor to the user’s body via pulleys \cite{murayama_spidar} or exoskeletons \cite{tsetserukou_exointerfaces}. An exemplary device is the Phantom, a desktop sized robotic arm featuring a pen as its’ ending. Phantom or comparable systems have been used for pen-based menu interaction \cite{oakley_solving}, for rendering bar charts for visually impaired users \cite{wall_assessing}, and so forth.

    Also using Actuated Workbench’s principle of magnetic forces as guides, Depend is a sketching system that uses a custom ferromagnetic surface to actuate a ballpoint pen \cite{yamaoka_depend}. The system is unfortunately stationary but in turn provides 2D actuation across the surface. A re-iteration of this interface, Depend 2.0 \cite{yamaoka_pen}, mitigates the mobility issue by using asymmetric vibration patterns to generate a virtual traction force which the user must respond to and turn in that direction voluntarily; this is based on the same underlying principle as Traxion \cite{rekimoto_traxion}.

*** Interactive EMS Systems
    EMS has been around for over half a century. It is mainly used for medical applications. Over several years HCI community has grown interest. Following are several implementations related, worth mentioning.

    EMS is a technique originated in the field of medical rehabilitation that applies electrical impulses to involuntarily contact muscle fibers; these impulses are delivered to the user’s muscles via electrodes attached to the skin \cite{Kruijff_hapticfeedback, strojnik_programmed}.

    Recently, researchers in HCI started to build interactive systems based on EMS. The Possessed Hand \cite{tamaki_possessedhand}, for example, is a guidance device that helps users learn for example how to play a new instrument. Pedestrian Cruise Control informs the user’s leg muscles when to turn \cite{pfeiffer_cruise}. In contrast, \app{} actuates muscles directly, thereby eliminates the cognitive load involved by systems that merely inform users when to turn.

    One motivation for the use of EMS in interactive system is that it allows replacing motors, thereby resulting in much smaller, even mobile form factors. Muscle-propelled force feedback, for example, uses EMS to provide directional force-feedback (left & right) in mobile gaming \cite{lopes_musclepropell}. Pose-IO is an interactive wearable system that allows for eyes-free input output with a computer system \cite{lopes_proprioceptive}. Affordance++ extends on this concept by allowing objects to actuate the user’s hand in order to make it manipulate the object properly \cite{lopes_affordance++}.


* Applications
** Overview

   This thesis presents six applications designed for \app{}. These applications all share some common building blocks are all designed to be initiated by the user on demand. The user can start interacting with \app{} using an application keyword or continue with any of the standard pen and paper activities discussed earlier. To start an interaction user takes turns with the computer, describes a domain and gets the answers later by applying the required plotting motion. Following chapter will describe these applications as walkthroughs to illustrate different interactions with \app{}.


** Wind-Tunnel Simulation

   Following walkthrough with \app{} showcases a designer analyzing the aerodynamic properties of a car sketch. Walkthrough demonstrates the interaction principles of \app{} as it allows the designer to understand implications of the changes on the car form by sketching.

   User starts the interaction by selecting a domain from \app{}. This entry and the following sequence of actions constitute as input and prepares \app{} for output. In this case user writes the keyword, `windtunnel'. \App{} processes input for potential keywords to provide the transition. Tesseract \cite{tesser_ocr} classifies the input, later to match to a keyword in a dictionary. `Windtunnel' keyword is followed by the number `10', which signifies the wind speed in this context. This number configures the tunnel entry speed (in meters per second) of simulated particles. `Windtunnel' command optionally expects this configuration, otherwise default value is used. Input after the keyword is checked against spacial proximity, if in expected position, is sent to be classified by Tesseract.

   #+CAPTION: Start Wind Tunnel Application, Place Canvas
   #+NAME: fig:windtunnel1
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9716.jpg]]

   Once the keyword activates the domain, `windtunnel', user proceeds to define the boundaries of the simulation area. As displayed in the figure [[fig:windtunnel1]] user defines this two dimensional space with crop marks. At this stage \app{} stores windtunnel as an object with coordinates of the designated canvas. Input from Anoto Pen is further processed based on this context defined in the state. As the users sketch the car, points received from Anoto Pen are stored and continuously processed to construct the outlines of the shape which later is used to create streamlines.

   After minimum input requirements for the wind tunnel object are satisfied, user can interact with the canvas to receive an output. By design \app{}'s wind tunnel defines left boundary to be the entry point of the wind particles for the simulation. To plot a streamline user puts the Anoto Pen on the left of the canvas and starts pulling the arm thus the pen tip perpendicular to the entry axis. During this motion, \app{} steers the wrist of the user to plot the trajectory of the simulated particle in the wind tunnel. After plotting several times starting from different locations on the vertical axis, user can see an overview of the sketch's aerodynamic behavior through the field of streamlines. Figure [[fig:windtunnel2]] shows user plotting streamlines.

   #+CAPTION: Plotting streamlines
   #+NAME: fig:windtunnel2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9749.jpg]]

   As wind tunnel object exists on a certain location of the paper, users can easily change the context by using an empty space on the paper. Moving to middle of the page and writing the keyword `windtunnel' and wind speed followed by the crop marks, user creates another windtunnel object with the associated canvas. User continues the interaction by making a new sketch for the second car form to be simulated. In proximity of the new canvas, starting from the entry point for the second simulation area, user plots the field for the windtunnel. Figure [[fig:windtunnel3]] shows the user plotting the second  windtunnel.

   #+CAPTION: Plotting streamlines for the second car
   #+NAME: fig:windtunnel3
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9762.jpg]]

   At this point of the walkthrough user continues to investigate and make sense of the data generated by \app{}. In order to take a deeper look at a specific location on the simulation area, user inputs a wind tunnel application specific command, `crosssection' to select a data set. Figure [[fig:windtunnel4]] shows that second car's streamlines look straighter, which in return may suggest better aerodynamic performance. User writes `crosssection' and names it `sedan' referring to the form of the first car sketch. `sedan' is the variable name that allows later recall. To select these variables, user draws a straight line on the streamlines just after the tail of the car, using the plotted canvas and the sketch as a reference. User repeats the same action on the second car to select another data set and names it `hatchback' on the process. Two selected data sets are now available for further analysis.

   #+CAPTION: Capturing Data for Line Graph
   #+NAME: fig:windtunnel4
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9768.jpg]]

   To compare stored data sets, user moves to an empty space on the paper and starts a new object with the keyword `plot' followed by the variable name that refers to the data set stored earlier, in this case `sedan'. Plot keyword also requires an axis to be specified as target. Users define such areas with two perpendicular lines, which are classified by the back-end as axis objects. The region defined by the axis lines describe the canvas area for the plot object. Similar to a manner of plotting streamlines user plots for first car. User repeats the action with the same keyword `plot' followed by the second variable, `hatchback'. Plot keyword expects an axis, in this case user selects an existing axis on the paper. By plotting two data sets on the same axis, results can be visually compared in the respective spacial context. Figure [[fig:windtunnel-captured]] shows the user plotting the wind speed at the cross section defined for each windtunnel.

   #+CAPTION: Plotting Selected Data Set
   #+NAME: fig:windtunnel-captured
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9777.jpg]]

   Walkthrough continues to demonstrate how the user dives deeper in to the generated data, to better understand the difference between the performance of two car forms. Two tail speed plots seem to significantly differ at the negative crossing. Negative wind speeds would likely to be an indication of turbulent areas, thus could signify higher wind resistance. Figure [[fig:windtunnel5]] shows the user inputting a new keyword, `zoom' and selecting a region using crop-marks. Selected area is assigned to a variable, in this case `tail'. Tail is a modifier that refers to respective regions of both data sets stored earlier. With a similar fashion to plotting wind speeds, selected region is plotted again. With this interaction user takes a closer look at the area of interest on the previous analysis, result of the plot can be seen on figure [[fig:windtunnel5-1]].

   #+CAPTION: Zoom at data set
   #+NAME: fig:windtunnel5
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9785.jpg]]

   #+CAPTION: Plot Zoomed region for the first sketch
   #+NAME: fig:windtunnel5-1
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9788.jpg]]


   On the final step of the walkthrough user decides to compare drag coefficients of two bodies in the wind tunnel. Drag coefficient is an aerodynamics concept, a unit-less ratio that is used as an indication of the aerodynamic performance of body in a fluid. \App{} wind tunnel application allows calculation of this value on the sketch. This example illustrates how \app{} can output scalar values and perform sense making on them. User starts of by writing `plot drag', which is a keyword followed by a domain specific modifier. Plot drag command requires an axis and a sketch inside a wind tunnel canvas. \app{} provides the user some flexibility on how to configure the widget. User can either write the name of the wind tunnel object, as of `plot drag sedan' or directly select the car figure from the context of the wind tunnel with a pig tail on the car body. After the selection, user draws a line and annotates `0' and `1' as the minimum and maximum values of the axis, which is the last configuration \app{} requires to make an scalar value output.

   #+CAPTION: Scale widget comparison
   #+NAME: fig:windtunnel6-1
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9794.jpg]]

   #+CAPTION: Plot second widget comparison
   #+NAME: fig:windtunnel6-2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9799.jpg]]

   After the input sequence, plot widget can be used for the output. To initiate, user drags the pen starting from the point annotated as `0' up and when tip is on the right point of the scale \app{} pushes the hand perpendicular to leave a tick mark and up moving pen away from the paper. Figure [[fig:windtunnel6-1]] shows this step of the interaction. Point of the tick is proportionally mapped to the size of the axis defined and annotated on the paper. Same action is repeated for the second car as seen in figure [[fig:windtunnel6-2]], which shows the use of the same axis from the previous plot. After plotting both values, user can compare the performance of both forms based a scalar value calculated by the simulation.

   After these sequence of actions, user gains insight to aerodynamic properties of the forms put on paper as sketches, which would require complicated calculations or computer modeling otherwise.


\newpage{}

** Other Application Scenarios
   \App{} allows users to accomplish complex sense making tasks with the help of an non intrusive back-end. In order to further illustrate these capabilities following applications are implemented.

*** RC Filter

   Figure [[fig:rcfilter]] shows \app{}'s filter design application built to help implementing first-order RC filters.

   #+CAPTION: RC Filter Design
   #+NAME: fig:rcfilter
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/rcfilter.jpg]]

   Filter design application is used for understanding different filter designs by observing their frequency response. The domain is selected by writing the keyword `RCfilter' followed by a variable name in this case `highpass'. User further inputs required parameters as in keyword, variable sequence, as shown on figure [[fig:rcfilter]] as `RCFILTER CAP 47\micro{}F'. After the environment is initialized, user plots the the frequency response to observe the design of the RC filter. At this step user changes the variables and re-plots the response, which allows to iteratively design filters with adjusting components.

*** Solving Math Equations

    Figure [[fig:mathequations]] show how \app{} interfaces with Octave to enable user to accomplish complex mathematical problems.

   #+CAPTION: Plotting Math Functions
   #+NAME: fig:mathequations
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9697.jpg]]

   Figure [[fig:mathequations]] shows user plotting a fifth degree polynomial. Using the keyword `F(X)=' user stores parameters of the polynomial in to the state. User later recall this variable with the `plot' keyword, followed by axis definition

   #+CAPTION: Calculating the integral of a function
   #+NAME: fig:mathequations2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9698.jpg]]

   After the plot action, user calls `integral' keyword, specifies the input and a target value. Which in return allows to spatially observe the output, where area under the curve reaches the target value. Figure [[fig:mathequations2]] shows the user getting the output of the `integral' command query.

*** Forms and Menus

    \App{} allows symmetric input and output using widgets drawn on paper. Following figure shows how user can setup a multiple choice menu to configure setting of the \app{} itself on paper.

   #+CAPTION: Query status of the checkbox form
   #+NAME: fig:formsandmenus
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9706.jpg]]

   Figure [[fig:formsandmenus]] demonstrates a widget to configure \app{}. It displays a multiple checkbox example on top and a radio button below. Multiple checkboxes are initiated by the user with the keyword `channel', followed by `?'. User then defines the list of possible values separated by square brackets. After the widget is configured, user traces the horizontal axis, \app{} draws tick marks on active channels. 

   #+CAPTION: Input to a form widget
   #+NAME: fig:formsandmenus2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9707.jpg]]

   As mentioned earlier, this widget is symmetric as user draws a cross on brake channel to activate it. Figure [[fig:formsandmenus2]] shows the input sequence. This is a simple appication of the radio button.

*** Fitting Trend Lines
 
    In Figure [[fig:formsandmenus]] illustrates the use of statistical functions with \app{}. In this example user accesses and plots a data set, further plots a trend line to better understand the set.

   #+CAPTION: Fitting Trend Lines
   #+NAME: fig:formsandmenus
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/bar_IMG_9675.jpg]]

   In fitting trend lines scenario user is exploring a data set concerning sales arranged by months. User starts this interaction with the keyword `barchart' followed by the variable `sales'. Bar chart requires an axis, which is defined by the user after keyword is invoked. A set of discrete values are mapped on the x-axis through the tick-marks drawn by \app{} as the user scans the axis. In this case user chooses to annotate the x-axis with the months. \App{} is not outputting as the user is writing on an inactive area. When user decides to output a value, starts with a pen-down in proximity of the intersection between the peak of the tick mark and the x-axis and scans vertically, finally \app{} outputs a dash to the left followed by a pen up which signifies the column. 

   This scenario further extends as user applies `plot' with `linearfit' on to the bar chart object. User starts dragging the pen from the starting point on to the y-axis and \App{} outputs linear regression as a line.

*** Optics Simulator

   #+CAPTION: Ray tracing simulation using convex and concave lenses.
   #+NAME: fig:optics
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/optics_IMG_9671.jpg]]

   Optics simulator allows exploring how rays of light refract in convex and concave lenses using \app{}. In Figure [[fig:optics]], user sketches a convex lens and explores how light rays refract through it. The application is initiated with writing a keyword, `optics' followed by defining a region with crop marks. When the user drags the pen through the lens, \app{} deviates the wrist based on the properties of the lens being simulated.


* Implementation
** Overview

   Current implementation of \app{} uses an Anoto Pen & Paper\cite{anoto} for input and a medically compliant 8-channel portable EMS simulator (from HASOMED \cite{hasomed}) for output. Tracking data from the Anoto pen is relayed through a windows machine to the python back-end running on a Mac OSX. Communication between the EMS machine and the python back end takes place through the custom serial protocol via USB. Current implementation only uses 4 channels of the EMS device. This setup can be miniaturized with a hardware similar to the one proposed in Proprioceptive Interaction \cite{lopes_proprioceptive}.

  #+CAPTION:    System Overview
  #+LABEL:      fig:muscle-plotter-overview
  #+ATTR_LaTeX: :width 110mm
  [[./images/teaser.JPG]]

   Following chapter will further describe the implementation in detail. First, the input module is going to be described, later output of the system will be detailed. Finally the back-end that orchestrates two will be extensively analyzed. Back-end system consists of  several different modules specializing in different tasks, which will all be demonstrated in detail.

** System Input
*** Tracking System

    Input to the system is handled by the Anoto Pen & Paper that acts as a precise tracker \cite{anoto}. the Anoto Paper has a patented dot pattern that encodes the location data for each point. The accuracy of the location is quite high where each millimeter encodes up to 30 unique points. The camera placed inside the pen tip scans and returns the value of the coordinates as long as the pen is pushing on to the paper. The angle of the pen influences the quality of tracking. The users are advised to hold the pen at an upright angle. This is importing using \app{} as a steady stream of observed points allows control loop to function properly. It is also important to mention that there is constant delay as the pen captures and analyses this image. This delay also has a detrimental effect on the performance of the control loop. The effect of the delay will further be discussed later in the control loop section this chapter. In the current implementation of \app{}, there is a Windows server running the drives provided by the Anoto company, relaying data to the back-end server. The details of these drivers (from the vendor we’inspire) is confined by a non-disclosure agreement.

    #+CAPTION:    Anoto Pen and Paper
    #+LABEL:      fig:pad-placement-flexor
    #+ATTR_LaTeX: :width 90mm :float
    [[./images/flexor.jpg]]

    The communication from Anoto Window API and the python back-end is done via Open Sound Control (OSC). Each observation of the Anoto Pen is packaged and contains a location, nature of the observation ( pen up, pen down and drag) and a time-stamp. Time stamp received is used for speed calculations. OSC packets are relayed to the python server through Ethernet. Measurements show that communication delay through Ethernet is insignificant compared to constant processing delay introduced by the pen hardware.

** System output

    \App{} output is communicated through electric muscle stimulation in to the arm of the user. Hence configuration of the pads on the arm and the machine that sends the signals are analyzed under the system output section of the thesis.

*** EMS Machine

    EMS machine by HASOMED is capable of generating single pulses of stimulations up to a frequency of 400Hz. In our implementation at a given time two channels are active at most, as a result, each muscle shares the capacity. When in a generic travel mode of the control loop, each side of the arm is stimulated with 200Hz. \App{} pushes the capacity of the signal generator to achieve a feeling of continuous actuation.

    In addition to the frequency of pulses, the EMS machine allows to control the amplitude and duty cycle of each pulse. \App{} uses amplitudes ranging from 6mA to 18mA based on calibration results. Duty cycle ranges between 20\micro{}s to 500\micro{}s, which provides a very large dynamic range of modulation. \App{} mainly controls duty cycles to achieve gradients of actuations. At specific situations, the amplitude of the pulses are temporarily raised to boost actuation that will further be described in the control loop section.

*** Pad Placement

    Medical grade EMS Machine produced by HASOMED is used to stimulate the arm of the user. In the current implementation 4 channels of the machine is connected to the arm of the user. Each channel is responsible for a different axis of motion. For a right handed setup; flexor carpi radialis moves the pen left, extensor carpi radialis brevis and partially flexor digitorum moves the pen right. Flexor carpi ulnaris is used to push the pen onto the paper, which in return helps to reduce oscillations and slow down. Finally extensor carpi radialis longus lifts the pen up from the paper. Following figures [[fig:pad-placement-flexor]] and [[fig:pad-placement-extensor]] illustrate the pad placements.

    #+CAPTION:    Pad Placement - Flexor
    #+LABEL:      fig:pad-placement-flexor
    #+ATTR_LaTeX: :width 134mm :float
    [[./images/flexor.jpg]]

    #+CAPTION:    Pad Placement - Extensor
    #+LABEL:      fig:pad-placement-extensor
    #+ATTR_LaTeX: :width 134mm :float
    [[./images/extensor.jpg]]

** Back-end System

   A back-end system handles the communication of the input from the Anoto Pen to the output of the EMS machine. Output of \app{} has to be specifically adjusted according to the physiology of the user's arm, as a result back-end system implements a calibration procedure. Calibration values acquired are used to drive the control loop model, which is extensively described in the following sections. Input from the tracker is constantly analyzed to respond based on the state of the interactions, these include state transitions and input classifications. Management of the control-loop and state-transitions with the context changes on the paper is abstracted in an API. This API allows to initiate and controls custom widgets described in this section. Finally application specific implementations are touched upon.

*** Calibration Process

    Calibration is an important aspect of current EMS applications. \App{} requires meticulous calibration to be adjusted specifically for each user, since for each user pen holding posture and arm physiology is unique. Values collected may need to be adjusted for long sessions as muscle fatigue and getting used to the plotting action may change the reaction of the arm to the actuations from the control loop. \App{} calibration generally takes place in three steps, with iterations and repetitions if necessary, based on the skills and the comfort levels of the user. Back-end system implements several methods to make calibration observations possible, each illustrated in the following section.

**** Comfortable actuation current

     The throughput of the motion created by EMS changes dramatically based on the anatomy of the user's arm. Several factors, such as muscle size, skin thickness and hair density causes these variations. For the first step of calibration \app{} implements a script that step by step sweeps up the intensity of the milliamps applied to each side of the arm (left and right). The experimenter observes the minimum current that starts the motion and a the maximum current that results in a significant motion but still is not painful. Duty cycles of the signals used in this step are kept at 200\micro{}S to allow finding a suitable dynamic range that can be can be used on the next step. Table [[tab:calibration-results-amps]] shows comfortable signal intensities for each participant, that were used as the starting point of the calibration.

     #+CAPTION: Signal intensities for Participants in milliamps
     #+NAME:   tab:calibration-results-amps
     #+ATTR_LATEX: :float
     #+ATTR_LATEX: :align |c|c|c|
     |--------+----------+--------|
     |        | extensor | flexor |
     |--------+----------+--------|
     | User 1 |       11 |      8 |
     | User 2 |       12 |      8 |
     | User 3 |       10 |      8 |
     | User 4 |        8 |      8 |
     | User 5 |        9 |      7 |
     | User 6 |       10 |      8 |
     | User 7 |       11 |      9 |
     | User 8 |       11 |      8 |
     |--------+----------+--------|

**** Slope gradients

     After the comfortable range of intensities for the EMS is determined, user is asked to draw straight lines along the paper in the posture required to plot with \app{}. At this calibration step, calibration script actuates user's arm with random pairs of currents on each side. The script records the resulting angle after each actuation. Figure [[fig:angle-overview-sheet]] at the end of this chapter showcases the marks on the paper after such a trial. In this case all actuations take place on the same horizontal axis for visualization purposes, however this location is random on normal trials to avoid users expecting a signal at a certain point. After a desired number of trial pairs, averages of the slopes are observed on a two dimensional visualization. Figure [[fig:angle-overview]] showcases this interface. Lighter colors correspond to smaller slops, while darker colors signifies pairs resulted in a higher slop. To conclude this step, three pairs that result in maximum variation between resulting slopes are chosen for each side. Pairs that consistently result in similar results are desired. It is easier to create jerky motions with EMS, however slow controlled actuations are harder to generate. Actuation of both sides, using both opposing muscles, allows \app{} to increase control on the wrist. Table [[tab:calibration-results]] shows the pairs used for each participant during the user study.

     #+CAPTION: Results of the slope calibration for the User Study Participants
     #+NAME:   tab:calibration-results
     #+ATTR_LATEX: :float
     #+ATTR_LATEX: :align |c|ccc|ccc|
     |--------+----------+--------+--------+---------+---------+--------|
     |        | extensor |        |        | flexor  |         |        |
     |--------+----------+--------+--------+---------+---------+--------|
     |        | weak     | middle | strong | weak    | middle  | strong |
     |--------+----------+--------+--------+---------+---------+--------|
     | User 1 | 100/185  | 80/190 | 0/220  | 170/130 | 180/110 | 240/50 |
     | User 2 | 80/160   | 80/200 | 0/220  | 150/90  | 180/90  | 210/60 |
     | User 3 | 60/260   | 50/290 | 40/330 | 130/130 | 150/110 | 190/50 |
     | User 4 | 100/165  | 80/200 | 0/230  | 170/130 | 215/110 | 240/50 |
     | User 5 | 100/175  | 80/200 | 0/230  | 190/110 | 215/90  | 240/50 |
     | User 6 | 100/175  | 80/200 | 0/230  | 180/100 | 210/90  | 240/50 |
     | User 7 | 100/185  | 80/200 | 0/220  | 170/130 | 210/110 | 240/50 |
     | User 8 | 100/185  | 80/200 | 60/210 | 170/130 | 210/110 | 240/50 |
     |--------+----------+--------+--------+---------+---------+--------|

    #+CAPTION:    Sample trials on paper
    #+LABEL:      fig:angle-overview-sheet
    #+ATTR_LaTeX: :width 132mm
    [[./images/calibration/foto_scratch.jpg]]

    #+CAPTION:    Angle visualization
    #+LABEL:      fig:angle-overview
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/calibration/web-viz.png]]

**** Brake Calibration

     \App{} has two modes for brakes, following section on control loop will further detail each. Which ever mode is active, the intensity of the brake has to be adjusted for the specific user. Back-end system, uses an extension of slope-gradients calculation presented earlier to enable these adjustments. In brake calibration step, users draw lines similar to the last step, but this time after a random time after actuation brakes are initiated. \App{} and the calibration assistant observes how efficiently wrist motion stabilizes to select the most comfortable brake intensity for the user. Following table [[tab:calibration-brake-results]] shows all the brake values used for the participants of the user study.

     #+CAPTION: Results of Brake and neutral parameters
     #+NAME:   tab:calibration-brake-results
     #+ATTR_LATEX: :float
     #+ATTR_LATEX: :align |c|c|c|
     |--------+---------+---------|
     |        | neutral | brake   |
     |--------+---------+---------|
     | User 1 | 60/110  | 140/200 |
     | User 2 | 120/120 | 140/180 |
     | User 3 | 60/110  | 155/210 |
     | User 4 | 60/110  | 160/200 |
     | User 5 | 100/80  | 160/130 |
     | User 6 | 100/80  | 140/120 |
     | User 7 | 60/110  | 160/160 |
     | User 8 | 60/90   | 120/160 |
     |--------+---------+---------|


*** Control Loop
    Control loop of \app{} uses a series of strategies based on the state of the user's hand motions and the target position. Possible situations and associated strategies are further illustrated in the following section. Key principles are highlighted in the following figure [[fig:control-loop]].

    #+CAPTION:    Key Aspects of the Control Loop
    #+LABEL:      fig:control-loop
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/control-loop.png]]

**** Model of the Human Wrist

     \App{} uses a simple model of the human arm to manage the motion of the wrist. The wrist is assumed to be a level attached to two strings. When the wrist is stationary, tension on both sides are equal, hence forming an equilibrium. Wrist motion takes place when tension on one of the strings changes as described by the `equilibrium point model' \cite{schmidt_motorcontrol}. Stimulation through nerves and muscle fibers result in contractions stronger on one side of the wrist. When one side is contracted more then the opposing side, motion occurs in direction of the tenser side. As a result same target position can be reached with different configurations of contractions on opposing muscles. When the wrist position changes, the length of the muscle fibers also change, perhaps to find another equilibrium point when forces are again equal on each side again. Figure [[fig:equilibrium-point-model]] showcases this principle. Any given static position of the wrist is an equilibrium of forces caused by tension on opposing muscles. \cite{schmidt_motorcontrol}. \App{} relies on these principles to achieve the accuracy it needs as both muscles on opposing sides are sequentially stimulated in rapid successions. In other words intended position of the arm can be reached by applying different pairs of impulses to flexor and extensor muscles.  Moreover increasing the tension on both sides allow to override the tension naturally applied by the user. This observation can also be deferred from the data collection step of the slope calibration process.

     #+CAPTION:    Equilibrium point model for the User's Arm
     #+LABEL:      fig:equilibrium-point-model
     #+ATTR_LaTeX: :width 91mm :float
     [[./images/spring-mass-model.png]]

**** Targeting and travel
***** Control Cycles

      Control-loop of \app{} consists of control cycles executed consecutively. Each cycle makes observations and acts based on the respective state relative to the target. Figure [[fig:control-loop-fast]] illustrates consecutive decision cycles on the give curve. At a given point, when a control cycle begins expected trajectory of the pen tip is calculated keeping in mind the transmission and processing delay of the Anoto Pen. In other words when the back-end reads the observation, the user is actually at a later point of the plot. This delay has been measured to be around 0.1s. As seen On figure [[fig:control-loop-fast]] each green dot is the calculated trajectory, where blue points represent the respective targets for that specific cycle.

     #+CAPTION:    Observed and Target Points Visualized
     #+LABEL:      fig:control-loop-fast
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/loop_in_action.png]]

***** Dynamic Adjustments

      If the user is lagging behind the target, the signal intensity applied to muscle that that causes the delay is increased by 1 mA. The lag is constantly stored on each control cycle. When the cumulative lag in previous cycles is above 0.6mm, boost is applied. Moreover if the next cycle still lags above the 0.6mm threshold, the boost is increased 2 mA. Such an increase causes the arm to respond faster then the duty cycle changes using in the normal mode. This adjustment can be considered as the integral part of a classical PID controller.  

***** Modes of Braking

      As mentioned earlier \app{} uses two modes of braking strategies. What ever the strategy is brakes are activated at same certain situations during the control loop. At the observation and estimation state, \app{} calculates the expected location and later the expected trajectory. If this trajectory:
 - is pointing towards the target
 - the user has been away from the target for a certain distance
 - and expected trajectory is is measured to have an intersection with the target
brakes are activated. This mode can be considered as the derivation component of a traditional PID controller. Main aim is to reduce the oscillations occurring while the plotting takes place. Figure [[fig:control-loop]] shows the brake activation cycles with cyan circles on the top curve. Bottom curve showcases observed and target points as in the previous figure. Following sections will identify two modes of braking.

     #+CAPTION:    Brakes applied during the plot 
     #+LABEL:      fig:control-loop
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/crazy_fast.png]]

****** Tensing Up both sides

       First braking strategy is based on the two channel implementation of \app{}. This mode has been used in the user study, while the findings pointed towards a better implementation described in the next subsection. This strategy uses high intensity pulses on each side of the arm to achieve and equilibrium point at a neutral angle. As mentioned in the [[*Model of the Human Wrist][model of the human wrist]] section, high intensities on both sides override previous motions to reach an neutral position. However observations during the study showed that this created a confusion for the users when in combination with them momentum of the plotting action itself, as they were confused with such impulses expecting a resulting motion on either sides.

****** Additional channel pushing down
       
       Second mode of braking uses an additional channel thrusting towards the paper, as mentioned in the pad placement section. This enables \app{} to utilize the power of arm muscles that are not activated by the steering motion. As a result the intent of the system is also perceived more clearly avoiding confusions.

**** Ending an interaction

     Control loop also implements a feature to signify when a plot is over. This consists of a strong single pulse in the direction away from the paper. When a certain position is reached, \app{} issues pen-up command, which in return lifts the arm away from the paper.


*** Higher level API for Flow Control

    \App{} interactions are built upon several types of widgets designed. These widgets leverage pen-input techniques such as crossing to select 1D primitives (CrossY \cite{Apitz_crossy}), underline and crop marks (Papiercraft \cite{liao_papiercraft}), and a pigtail gesture to select 2D primitives (Scriboli \cite{Hinckley_delemiters}). All widgets output when the user starts the interaction from the dedicated locations in its’ boundaries on the paper context. The output ends when \app{} stimulates the muscles that cause the user to lift the pen’s tip from the paper.

   Canvas elements in forms of widgets enable the user to control the flow and structure of \app{}'s output. We have designed several widgets for different data structures and plotting intentions. Scalar values are represented along a line, they consist of a single axis. Functions are represented in a two dimensional area, as they exist on two axes. These widgets on paper, what ever the underlying data structure is, have some characteristics in common. All the canvas elements define an actual space on the paper with designated areas for interaction. These elements have essentials to be initialized, as well as optional modifications to shape and control the output. Widgets determine where electronic muscle stimulation is going to be active, which in return serves as starting point for the plots. In the following section widgets are described based on their underlying data structure, describing the methods of initiation and use. All elements are drawn onto the paper, it is important to remind that they persist in an inactive state even when the user is working on an other part of the paper. They can be reused with appropriate commands.

**** Single axis elements

    Single axis elements are designed to output scalar and Boolean values that are projected onto a line. Resulting value is represented in spacial reference to the domain of the axis drawn for the widget. These can be used for the output of a single class as well as to compare different classes in the same spacial context. Output domain can range from Boolean to real numbers. Limitations imposed by \app{} determines the sense making possibilities and the fidelity of the output. In the discussion section the design principles that allows the users to modify the axis to achieve reasonable outputs.

    To initiate a single axis element, after writing the designated keyword to initiate, user draws a line in any orientation on the paper. By default, south-west facing edge of the line is assigned to the minimum value, while north-east facing edge is assigned to the maximum value. If the minimum and maximum values are not defined in the next optional step, default values for the specific domain is used. For example 0 to 1 in drag coefficient comparison, or the x value of the maximum of a plot would be projected on to the domain represented by the plot itself in maximum analysis of a function. The axis can be scaled by the user simply by reannotating the maximum and/or the minimum value.

    After all the essentials are placed on the paper, the scale component is ready to use. It starts of by user placing the tip of the pen at the beginning of the scale. If the pen lands in the accepted proximity of the origin, ems channels on both sides (left and right presented earlier) of the arm are activated at a tactile feedback level that doesn't actuate the user. This output only signifies that an output interaction is taking place, gives the feedback to the user that output is activated. At this point, user starts dragging the pen keeping the tip on the paper aligned with the drawn axis to the end of the axis. The back-end system, tracks user's motion and triggers a quick nudge followed by a pulse on the upper channel that lifts the hand up. This gesture leaves a visible trace behind on the axis, where desired value is projected on the the axis on the paper. The user can observe and annotate the value, as the widget output is not active unless drag initiates from the origin of the axis. 

    Following subsections highlight application specific types of single axis elements.

***** Scale Widget 

      The scale widget outputs a single value per interaction, useful for comparing scalar values. In case of clustered values in the same scale, muscle-plotter will output them by alternating the tick-marks to the left and right where the tick make is placed when desired value is reached. In the previous walkthrough and scenarios, scale widget is presented in: finding the drag-coefficient, finding an integral of a function and plotting individual bars in a chart. Just as with the axes of a plot, the scale widget allows to redefine its axis for zoom in/out that allows higher fidelity output.

***** Radio button
      The radio button is a symmetric widget that allows both enabling a disabled option or disabling an active option and receiving the status of that option. This can also be used for a yes/no dialogues, or make simple queries to app{} (e.g., to check if a number is prime). Radio button widget is presented in the form example scenario where the user configures the intensity of an the brake channel.

***** Checkbox
      The checkbox is an extension of the radio button that allows for multiple choices to be active. This widget is useful for finding elements in lists such as options in a form. This example is illustrated in the form scenario where user queries which EMS channels are currently active.

**** Double Axis Elements

    Double axis elements have a major and a minor axis, they are useful to plot parametric values as well as functions. As previously illustrated user drags the pen along the major axis, while the system takes the tip of the pen to the corresponding minor axis value with respect to the specific location on the major axis.

    The walkthrough section displayed 3 specialized instances of the line chart widget, i.e., wind tunnel, the tail profile plots and the zoomed plots. It is important to mention that the line chart widget supports the following interactions through context specific commands: zoom in/out by relabeling the axes, zooming in by selecting a region inside with crop marks, fitting a line through existing data points, performing operations on data traces and re-plotting the results as a trace (e.g., derivative of a function). Figure [[fig:axis-roto]] showcases the anatomy of a generic plot.

     #+CAPTION:    A Generic Canvas with Axes
     #+LABEL:      fig:axis-roto
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/axis-rotoscope-01.png]]

    As we have presented in the walkthrough, our main contribution comes from the spatial expressively of plotting one-to-functions, such as streamlines of the wind tunnel or the speed values for a selected cross-section. For both use cases the space defined on the paper is same in nature, while the tools to define are domain dependent. In the wind-tunnel case, there exists a line for every point on the vertical start axis as stream lines emerge from a single solution of a vector field. The anatomy of the wind tunnel canvas is presented in [[fig:windtunnel-roto]]. On the other hand for the speed values line example, there exists one unique line, that the user can plot. An example of such an axis is shown in the figure [[fig:axis-roto]]

     #+CAPTION:    A Windtunnel Object
     #+LABEL:      fig:windtunnel-roto
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/canvas-rotoscope-01.png]]

    In order to initiate a multiple axis plot, the user has to define a space on the paper. This is done by drawing two perpendicular lines representing the axes or crop-marks that encompasses the area. In case of a function plot, after defining axis lines user can optionally update the domain. Otherwise, defaults for the specific example is used just as mentioned in single axis examples.
   
    In a similar fashion to scales, the user should start at a specific position to instantiate the plotting procedure. In a generic plot, the output can be located in different quadrants. We have defined a method for the user to locate it to start plotting. Following interactions to find plot starting points are similar in nature to the scalar interactions described above. In the first case, where there is a zero crossing on the negative side of the major axis, user places the tip of the pen to the far left (negative, west) of the horizontal, major, dragging axis. The paper should have been rotated to a comfortable angle for a convenient plot. Then the user follows the axis, when zero crossing is reached, \app{} takes over the control of the arm to output the rest of the plot. If necessary, the user can rotate the paper 180 degrees and plot the negative side of the desired line.

    In the case of in the case of no zero crossing before the origin, \app{} signals a pen-up before first scanning starts. At this point the user knows that there isn't a zero crossing between 3rd and 4th quadrants. In the next step user should scan the y axis, to find any y-crossings. Ideally user starts from the minimum point of the minor axis and drags the tip of the pen to the maximum point of the axis. If there is a y-crossing of the plot, \app{} assigns a pen-down on the target position. From this point on the user follows parallel to the major axis to continue as a normal plot. The negative side of the function can be plotted by rotating the paper in a similar manner to the first case. This method of finding the starting point is illustrated in the following figure [[fig:axis-start]].

     #+CAPTION:    Finding the starting Point
     #+LABEL:      fig:axis-start
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/axis-rotoscope-02.png]]

    In the last case, when there is no zero crossing between 3rd and 4h quadrants and there is no y-axis intersection, the second axis find attempt of the user is interrupted by a pen-up as the tip of the pen is place on the minor-axis, (y-axis). The users follows over the major axis to find the crossing there. \app{} takes over control as the crossing is reached. The plot can be completed in a similar manner by rotating it as described in previous cases.

*** Recognition System

**** Handwriting Recognition using Tesseract

     To recognize hand-written input \app{} uses Tesseract \cite{tesser_ocr}, a trained recognizer with several languages. It is likely to be the most robust open-source optical character recognizer \cite{compar_open_sourc_ocr}. While using Tesseract, \app{} only loads the training data for the English language and common symbols such as “?”, “(“, etc. 

     Recognition of \app{} takes place in two different modes based on the state and the expected commands. In the state where no application is initialized, \app{} looks for keywords. In order to accomplish that, the input from Anoto Pen is:

1. appended as an array of strokes as long as the center of those strokes are 3mm apart. This allows multi-stroke characters.
2. The center is further then 3mm but is 10mm range, strokes are appended in to a new array that signifies the second character.
3. When three characters are reached:
   - Points that belong to the same stroke are interpolated to complete a line.
   - Strokes belonging to the same characters are combined to form character
   - Finally each character is combined to form the observed word.
   - Final combination is converted to black and white and is sent to Tesseract.
4. If the recognition fails, \app{} continues to observe following strokes as long as their center is not further away then 10mm. The buffer that allocates the keyword candidate is discarded when user starts writing in an other location on the paper.


In the case of a state where the keyword `plot' is properly recognized, \app{} expects a function entry. Hence recognition is handled at the character level, skipping the second step described above. Each character, formed of combinations of strokes are delivered to the Tesseract. This format allows this allows the entry of "F(X)=SIN(X)” after the `plot' keyword.

     In order to improve performance of Tesseract in keyword recognition mode, the output is matched to the closest word using the Levenshtein distance (edit distance). This is essential for usability as many characters tend to result in false positives, such as “L” and “(“ or “X” and “K”. With the help of edit distance comparison, when Tesseract recognizes “P(OT” instead of “PLOT”, \app{} makes the comparison against a dictionary of keywords, since in the previous case the Levenshtein-distance is 1 (i.e., replacing one character gives a positive match). Maximum edit-distance accepted \app{} is the half of  the input word’s length rounded down.


*** Application Specific Implementations
**** Mathematical Applications

     To solve the mathematical formula, \app{} invokes Octave through its Python bindings. Octave is mainly used for mathematics (derivatives, integrals, and so forth) and for plotting functions from formula. \app{} interfaces with Octave by: (1) converting user-notation to Octave notation – when the user writes “sin(x)” it is converted to “feval((sin(x), [range-of-plot])”; then, (2) sending the formula to Octave, sampling it into points and returning it to muscle-plotter; and, lastly, (3) transforming these points to the Anoto paper’s coordinates and projecting into the user-defined axis.

**** RC Filter Response

     \App{} includes a simple solver for high and low pass RC circuit filters. It works by solving the filter equations directly in the frequency domain. The values for R and C are read from the users’ input through the domain specific language defined by the application, as in “cap 10UF” (i.e., 10μF) and “resistor 330” (in Ohms).

**** Statistic Applications

     To perform statistics operations we utilize Python’s Scipy Stats package. This allows us to invoke operations such as computing a standard deviation or a regression, which has been demonstrated at the example of a linear regression through the bar chart data.

**** Optical Ray Casting

     The optics demonstration is a simple 2D ray casting based on \cite{thin_python} that deals exclusively with concave and convex lenses. The lenses' focal points are simply proportional to the width of the drawn lenses bounding box.

**** Wind-tunnel Simulation

     The wind tunnel simulation is based on the Lattice-Boltzmann equations and adapted from Schroeder’s implementation \cite{lattic_boltz_simul_fluid}. To run a wind-tunnel simulation (i.e., to compute the wind speed streamlines) \app{} extracts the shapes drawn inside the wind tunnel application canvas. Later down-samples these shapes (e.g., the car) into a binary matrix of 200px height which contains the obstacles to the wind flow. After the sketch is transformed into the suitable format for the simulation input, Lattice Boltzmann equations are executed 30 times by always moving the wind-lines one more step and re-evaluating the collisions to compute the velocity flow. Finally once the user draws a line to get the wind streamline as output, \app{} uses Matplotlib’s streamlines function to obtain the streamline as a curve from the user’s pen down position as a starting point.


* User Study
  A user study has been conducted to understand spacial output production capabilities of \app{}. Participants repeatedly plotted a collection of preselected curves using \app{} in a random order. After the study target curves were compared to actuals on paper.

** Study design

*** Task
    For each trial, participants plotted one function onto paper using \app{} as displayed in figure [[fig:user-study-1]]. Participants were instructed to place the pen tip hence their hands on a starting marker to the left side of the paper. Later they dragged their hands towards the right side of the page, at a comfortable speed they desired. While dragging, \app{} has actuated the wrist to plot the target.

    #+CAPTION:    User Plotting
    #+LABEL:      fig:user-study-1
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/setup.png]]
   
    Each trial lasted for 16 centimeters from left to right. For each trial, target and measured points were recorded, as well as the duration pen tip was in contact with the paper. Eight target functions that were randomly served to participants are shown in figure [[fig:target-functions]]. First six functions labeled as Sin1 to Sin6 were composed by adding off phased sine waves of increasing frequency up to 0.5 cycles/cm. Remaining two functions consist of a triangular wave (denoted as Tri) and a half sine wave followed by a flat section (denoted as Flat). These two functions aim to explore how the system behaves with regards to abrupt changes in slope and curvature as well as to prevent participants from getting used to sine wave patterns.

    As every participant performed each function twice, total of 128 trials (8 functions x 2 repetitions x 8 participants) have been conducted over the course of a week.

*** Apparatus

    #+CAPTION:    User Plotting
    #+LABEL:      fig:aparatus-1
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/closeup.png]]

    Figure [[fig:aparatus-1]] shows apparatus for the user study. Participants wore \app{}’s electrodes on the wrist flexor and extensor muscles as described in detail in [[*Pad Placement][pad placement section]]. Participants were seated with the dominant forearm rested on the table to reduce fatigue. Plots were made using the controller described in implementation, which actuated flexors and extensors simultaneously but without brake channel, which was introduced as an outcome of the study. Brake effect was achieve via tensing both sides as described in the earlier section. During the study \app{} software administered the respective functions to the user; all other functionality was disabled. Study assistants, made sure change the Anoto Paper for each plot to avoid negative effects of repetition. 

*** Participants

    8 participants were recruited (1 female), between 22 and 26 years old (M = 23.9 years) from the local university. With consent of the participants trials were videotaped. Participants calibrated with the procedure described in Implementation section. Participants that were not comfortable with the EMS were not accepted for the trials as the purpose of the study was not to test usability of EMS itself.


** Study Results
   Raw data measured in Figure [[fig:target-functions]] shows all the curves drawn by each participant. The average error from respective targets across all 128 trials was 4.07 mm (SD=3.03 mm).

    #+CAPTION:    Target Functions
    #+LABEL:      fig:target-functions
    #+ATTR_LaTeX: :width 152mm :float
    [[./images/studyresults/figure_1.png]]

*** Preservation of sine-based functions

    Figure [[fig:target-functions]] also shows the average error per by function. As expected, there was an increase in error with the increase in the function’s highest frequency. Table [[tab:sine-based-results]] confirmed by a linear regression through Sin1-Sin6 with R2=0.64. To provide an estimation of how much each trial differed to the next, the reported standard deviations (SD) are between the averages of all trials for that specific function.

     #+CAPTION: Average Error for a sine-based functions
     #+NAME:   tab:sine-based-results
     #+ATTR_LATEX: :float
     #+ATTR_LATEX: :align |c|c|c|
     |------+-----------------+--------------------|
     |      | mean error (mm) | standard deviation |
     |------+-----------------+--------------------|
     | Sin1 |            2.45 |               1.42 |
     | Sin2 |            2.65 |               1.29 |
     | Sin3 |            2.66 |               0.90 |
     | Sin4 |            3.15 |               1.00 |
     | Sin5 |            4.55 |               1.31 |
     | Sin6 |           10.06 |               2.67 |
     |------+-----------------+--------------------|

*** Preservation of non-sine functions

    When plotting the two functions that contained abrupt changes in slope and curvature participants performed similarly to the sine waves. The results are summarized in the table [[tab:non-sine-results]]. Standard deviation is calculated against the averages of all users for the same curve as in the previous step. The results show that abrupt changes of curvature generate a similar error profile to smooth curvatures. The error increases with the rate of change is higher.

     #+CAPTION: Average Error for a non-sine functions
     #+NAME:   tab:non-sine-results
     #+ATTR_LATEX: :float
     #+ATTR_LATEX: :align |c|c|c|
     |------+-----------------+--------------------|
     |      | mean error (mm) | standard deviation |
     |------+-----------------+--------------------|
     | Tri  |            4.77 |               1.53 |
     | Flat |            2.29 |               0.82 |
     |------+-----------------+--------------------|

*** Preservation of features
    
    The plots in Figure [[fig:frequency-analysis]] illustrate in how far plots made through muscle-plotter preserved the original function. The plots show frequency histograms produced by means of Fourier Transformation. We see the original signal in green, as well as user-specific jitters—aka noise, in red. As the plots illustrate, jitters tends to revolve around frequencies higher than 0.5 cycles/cm.

    #+CAPTION:    Frequency Analysis
    #+LABEL:      fig:frequency-analysis
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/fft_2.png]]

    Jitters in Sin2 and Sin3 has very little impact on the signal (the same as observed in Sin1 and Sin4). This gets more challenging with Sin5, which has its highest partial at a wavelength of around 0.23 cycles/cm. Still, signal and jitters are clearly distinct, which means that the original function still stands out clearly, so that awareness of one’s jitters may allow users to visually filter out the noise. It is observed that distance between jitters and the signal gets smaller with increasing signal frequency until they start to overlap as in Sin6, suggesting that an essential part of this signal has been shadowed by the noise and thus has become unrecognizable.

    We conclude that \app{} is suitable for communicating signals of up to the frequency of 0.3 cycles/cm, but should not be used for frequencies higher than this. This limitation should be always kept in mind while designing applications for \app{}.

*** Speed/Accuracy trade off

    During the user study for the \app{} plotting speed was not controlled. Participants during the training we recommended to go faster or slower based on to achieve optimal control-loop performance. As participants picked their own pace when the actual trials has started, the results presented a wide range of speeds. This allowed to understand ideal completion times by comparing the results of each user.

    Participants of the study plotted 16 cm-wide functions in between 7.98 s and 29.5 s (M=16.17 s, SD=4.90 s). Figure [[fig:duration-accuracy]] demonstrates the resulting speed/accuracy trade off. Results showed that plots lasting shorter 11 seconds were worse then their longer counterparts. Also taking significantly more time then 11s didn't improve the results as trials above 11s had a steady average error of 4.07 mm.

    #+CAPTION:    Plot duration vs. Plot Accuracy
    #+LABEL:      fig:duration-accuracy
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/Fig5.png]]


* Discussion

** Drawing vs. Steering
   Working principles of \app{} limits drawing capabilities to a single axis, which can't be considered as a 2D drawing activity. More complicated data is plotted with repeating the same motion in different spacial contexts as seen in streamlines of the wind tunnel. Plotting with \app{} is based on a steering motion as pen draws a curve. Expanding these limitations to a two dimensional surface would require coordination of multiple muscles on the human body, arm, and wrist. Controlling such a complex motion with EMS would require extensive control over each possible channel, perhaps with some levels of abstraction. 

** Considering User study
   \App{} is a novel interface that has different limitations and strengths compared to traditional GUI based systems. User study we have introduced tries to understand the plotting capabilities of the system, to better understand applications possible. However usability of those applications are left out from the user study.

** Design Considerations
   Based on the findings of designing applications for \app{}, this theses points to a couple of principles that are important to consider to create usable applications.
   
*** Discoverability
    \App{} provides an interactive environment using user initiated components on paper. This approach differs from previous interactive systems as the user is expected to have a prior knowledge of the provided language. In many cases our interactions start with an empty sheet of paper. On the other hand screen based interactive systems provide discoverability as the system itself has a wider channel for output, such applications can start with a tutorial expecting the user to have zero prior knowledge. Designing applications for \app{} should consider this to provide an engaging experience. According to the domain of the application, command keywords could be flexible and adaptive, moreover similar to a natural language.

*** Interactive Text Books
    \app{} interactions require some input from the user side, in order to determine the domain and configure the output. In the simplest case, user has to accomplish a sequence of inputs to get a the first output. Predesigned worksheets would allow to simplify these steps, minimizing the learning curve as well as creating engaging interactions. Figure [[fig:optics-worksheet]] shows a sample prepared for testing. Combination of such examples could make up to interactive textbooks.

    #+CAPTION:    Optics Worksheet Example
    #+LABEL:      fig:optics-worksheet
    #+ATTR_LaTeX: :width 110mm
    [[./images/discussion/optics_ex1.png]]

    #+CAPTION:    Optics Worksheet Example 2
    #+LABEL:      fig:optics-worksheet2
    #+ATTR_LaTeX: :width 110mm
    [[./images/discussion/optics_ex2.png]]

*** User Feedback
    Usability theory for interactive systems inform the user about the state of the world. \App{} is able to provide positive and negative feedback in a non intrusive way with distinct gestures. Interactions with \app{} should make use of feedback messages, in order to provide the user with an awareness of the state of system. As the interactions happen on a piece of paper, certain locations marked by the user, should behave in a consistent way. The user can approach a plot for several actions, such as actual plotting, zooming into a certain section, re-labeling the axis or selecting a region for further analysis.

*** Widget size and expected error
    \App{} has a limited accuracy due to the limitations of EMS. Interactive elements on paper should be scaled at a size greater that leaves the expected error insignificant. For example, a continuous scale described previously should verify that the output will provide a significant answer.

*** Output Persistence and clutter on paper
    The output of \app{} is persistent on paper. When the user draws a certain plot on a given axis, the output stays on the paper way longer then the length of the interaction. In an example of function plotting if the outputs were made and their essential characteristics are not different enough, the answers can be mixed up. As a solution, the user has the flexibility to annotate the output. This would allow the number of distinct traces that can be recalled later on. However, after a certain number of plots, the intelligibility would diminish. This is an inherent problem with writing on the paper, where the user would extend to the empty space below or to the next page. \App{} widgets are reusable, however they are also easy to initiate.


* Conclusion

  This thesis presented \app{}, an interactive system based on electrical muscle stimulation that offers more meaningful and expressive output. It is designed to assist users in cognitively demanding activities, such as designing an aerodynamically sound vehicle, by providing them with access to a computer system while they are sketching on pen and paper.

  Muscle-plotter provides pen-on-paper interactions for both input and output. To interact, users input by writing, e.g., writing mathematical formulas or drawing shapes. The system outputs by actuating the user’s wrist so as to draw graphs, strokes, etc. In the thesis six simple applications have been demonstrated, including a wind-tunnel simulator, and RC circuit simulator, function plotting, as well as a set of generic widgets. To validate the accuracy wrist-actuation system, a user study has been conducted and presented.

** Future Work
*** Evaluate applications

    This thesis approaches the user study in terms of understanding the accuracy and plotting capabilities of \app{}. The accuracy of the system should be considered when designing applications. Quality and the usability of the data outputted for application specific domains can be investigated.

    As mentioned in the discussion \app{} preserves low frequencies while adding relatively small amounts of noise to higher spectrum. The cognitive capabilities of human brain remains as a question as it is unknown when added noise would totally hide away the intended answer. As mentioned usability of \app{} output can be further studied in a broader perspective.

*** Worksheet and Simulation Environments

    As mentioned in the discussion section, a sound implementation of \app{} can be implemented using specifically designed worksheets. Such a combination, would allow interactive textbooks to be designed. These can further be improved with a pen version that allows the trace to be erased as a pencil. Such a combination should be implemented and investigated to improve usability of muscle plotter.

*** Improve recognition

    \App{} uses Tesseract for character and keyword recognition. Tesseract is an excellent solution for optical character recognition, however hand-writing is a better task for classification using deep learning. Recent developments make it relatively easier to implement such a recognition system, which in return would significantly improve recognition performance of \app{}. Such an improvement would make more usable applications possible.


#+LATEX: \backmatter{}
#+LATEX: \newpage{}
#+LATEX: \printbibliography{}

