:SETUP:
#+OPTIONS: toc:nil date:nil title:nil
#+LATEX_CLASS: koma-book
#+LATEX_CLASS_OPTIONS: [a4paper, 12pt, twoside, BCOR5mm]
#+LATEX_HEADER: \usepackage[hmarginratio=1:1]{geometry}
#+LATEX_HEADER: \usepackage{mathptmx}
#+LATEX_HEADER: \usepackage[scaled=.90]{helvet}
#+LATEX_HEADER: \usepackage{courier}
#+LATEX_HEADER: \setkomafont{disposition}{\sffamily}
#+LATEX_HEADER: \setkomafont{subtitle}{\sffamily\Large}
#+LaTeX_HEADER: \usepackage[backend=bibtex,sorting=none]{biblatex}
#+LaTeX_HEADER: \addbibresource{/Users/doga/.org/bibtex/file-1.bib}
#+LATEX_HEADER: \usepackage{./source/introsections}
:END:
:VARIABLES:
#+LATEX_HEADER: \newcommand{\app}{\emph{muscle-plotter}}
#+LATEX_HEADER: \newcommand{\App}{\emph{Muscle-plotter}}
:END:
:HEADERFOOTER:
#+LATEX_HEADER: \usepackage{scrlayer-scrpage}
#+LATEX_HEADER: \ohead{Muscle-Plotter}
#+LATEX_HEADER: \ihead{Doğa Yüksel}
#+LATEX_HEADER: \ofoot[]{\thepage}
#+LATEX_HEADER: \ifoot{Master Thesis, TU Berlin, Fachgebiet X, 2016}
:END:
:INTRO:
#+LATEX: \frontmatter{}
#+LATEX: \begin{titlepage}
#+LATEX: \end{titlepage}
#+LATEX: \begin{hpititle}
#+LATEX: \end{hpititle}
#+LATEX: \begin{declaration}
#+LATEX: \end{declaration}
#+LATEX: \begin{abstract}
This thesis explores creating an interactive pen and paper application using Electrical Muscle Stimulation. Using this application users can input and get meaningful expressive output from a computer system in a mobile context. Using pen and paper allows the user to engage in cognitively demanding tasks, such as solving math problems. In the simplest case user inputs the a math function and later \app{} uses user's hand to plot the function. This example is further expanded into fitting lines through points, finding points of interests etc. These core components are demonstrated in six different applications from different domains.

\App{} is the first EMS system that produces spacial output, hence is more expressive then earlier systems proposed. In our user study, participants drew random plots within 4mm accuracy and preserved accuracy up to 3 cycles per cm.
#+LATEX: \end{abstract}
#+LATEX: \thispagestyle{empty}
#+LATEX: \newpage{}

#+LATEX: \renewcommand{\contentsname}{Table of Contents}
#+TOC: headlines 2
#+LATEX: \thispagestyle{empty}
#+LATEX: \newpage{}

#+LATEX: \listoffigures{}
#+LATEX: \thispagestyle{empty}
#+LATEX: \newpage{}
:END:

#+LATEX: \mainmatter{}
* Introduction

  Interactive systems based on electrical muscle stimulation (EMS) actuate users by sending an electric signal to muscle fibers and motor neurons through electrodes attached to the skin. The possessed hand \cite{tamaki_possessedhand}, for example, used this technique to assist users while learning the finger poses required to play an instrument.

  #+CAPTION:    Muscle Plotter - Teaser
  #+LABEL:      fig:muscle-plotter-teaser
  #+ATTR_LaTeX: :width 110mm
  [[./images/teaser.JPG]]

  Interactive EMS systems utilize the force generated by user's own muscles. Alternative implementations require some form of scaffolding working together with a motor. Using mobility of the body allows interactive systems that can be implemented in smaller form factors. Such systems are ideal for mobile use (mobile gaming \cite{lopes_musclepropell}) as well as wearable use (pedestrian cruise control \cite{pfeiffer_cruise}). EMS systems also enable implementing input/output interactions that use the same modality (aka symmetric interaction \cite{roudaut_gesture}) by using the same gesture language for input and output (\cite{lopes_proprioceptive}). This allows creating novel interactions with user's own body parts and allow to enrich capabilities of existing objects \cite{lopes_affordance++}. 

  Unfortunately, the price for these benefits is that the interactive EMS systems presented so far lack expressiveness. Existing interactive EMS systems output a single value, such as screen tilt \cite{lopes_musclepropell} or wrist tilt \cite{lopes_proprioceptive} or one of multiple behaviors \cite{lopes_affordance++}. Since subsequent output overwrites earlier output, users can only observe a single value at a given time.

  In this paper, we explore how to create more expressive EMS-based systems. \App{} achieves this by persisting EMS output, allowing the system to build up a larger whole. More specifically, (1) muscle-plotter spreads out the 1D signal produced by EMS over a 2D surface. Rather than repeatedly updating a single value, this renders many values into curves. (2) By adding the pen, we persist this signal, allowing the system to build up a larger display, which in turn enables longer and more meaningful interactions.

** Motivation

   Pen and paper is an important activity for concerning human creativity and productivity. The medium of pen paper is familiar for many people. Developing technologies that could enhance the capabilities of this medium can be beneficial to many. \App{} builds upon this idea and imagines posibility of a future interface without screens, an interface that could be miniturized and intergrated.

** Contribution

   \App{} extends on this line of work by providing a more expressive EMS-based system, which is attained by persisting the EMS output onto the paper. Older systems communicate via discrete poses of the users’ body, resulting with a single value any given time. \App actuates user's wrist while dragging the pen to lay down a curve. Since the curve persists on the paper, users can refer or get back to interact even after making several other interactions on the page. These characteristics lend itself to more expressive and longer interactions with the ability to communicate series of values, which later can be used to solve complex problems. 

** Thesis overview

   This thesis will continue by looking at related work in the next chapter. It will then further investigate walkthroughs of the applications developed for \app{}. In the following chapter, the implementation of \app{} is described. After implementation, a user study to understand capabilities of \app{} is presented. Last two chapters of this thesis is reserved for discussion and conclution.


* Fundamentals and Related Work

** Fundamentals

   \App{} builds upon pen and paper interactions, activities such as writing, note taking, sketching that is essential for human intellect. These activities form the pillars for developing own ideas, communicating and building upon them. Ullman et al. have investigated how mechanical designers used drawings, and observed that it 'acts as an extended memory', helps analysing and simulating forms, and enables communication of ideas \cite{ullman_importancedrawing}.

   This thesis is further related to interactive pen-based interfaces, interactive systems based on exoskeletons or electrical muscle situmulators. Following chapter will further investigate examples from the state of the art research.

** Related Work

*** Pen-based Interaction Techniques

    Interactive systems based on pen and paper has existed since the dawn of HCI. Already competent capabilities of pen and paper is further enchaced by intelligent systems and interaction techniques. Holding a pen is traditionally unimanual and that allows cooparative unimanual interactions through these interaction techniques \cite{Hinckley_coopbimanual, Guiard_asymetricbimanual}.

    Based of the principles mentioned above, interaction techniques developed of pen-based systems are as follows, connonically SketchPad \cite{sutherland_sketch}. Another example is `Teddy' which is a system that allows 3D modeling based on 2D sketching \cite{igarashi_teddy}. CrossY tackles the problem of interacting with GUI elements on a paper with a pen \cite{Apitz_crossy}. PapierCraft is another example where users can interact with the elements on paper using gestures such as pigtails, crop marks or underlines to acomplish actions such as copy & paste, linking, etc. \cite{liao_papiercraft}.

    Several other studies extend the use of pen and paper to an other domain in particular to mathematics. Flatland \cite{mynatt_flatland}, for example, is a pen-based interface for whiteboards that supports basic math and map drawing. Also, both MathPad \cite{laviola_mathpad} and Hands-on Math \cite{zeleznik_hands} are systems that provide deeper support for understanding of mathematics.

*** Haptic Output Systems

    Some researchers have taken tangible input further by using it not only for input but also for output. Notably the Actuated Workbench closed the loop for a tangible tabletop system by actuating the pucks using magnetic forces \cite{pangaro_actuated}. Another example for closing the loop comes from Gesture Output \cite{roudaut_gesture} in which the loop of touch gestures on a mobile phone is closed by actuating the user’s finger.

    Most haptic systems with sufficient force to actuate users transmit forces from a motor to the user’s body via pulleys \cite{murayama_spidar} or exoskeletons \cite{tsetserukou_exointerfaces}. An exemplary device is the Phantom, a desktop sized robotic arm featuring a pen as its’ ending. Phantom or comparable systems have been used for pen-based menu interaction \cite{oakley_solving}, for rendering bar charts for visually impaired users \cite{wall_assessing}, and so forth.

    Also using Actuated Workbench’s principle of magnetic forces as guides, Depend is a sketching system that uses a custom ferromagnetic surface to actuate a ballpoint pen \cite{yamaoka_depend}. The system is unfortunately stationary but in turn provides 2D actuation across the surface. A re-iteration of this interface, Depend 2.0 \cite{yamaoka_pen}, mitigates the mobility issue by using asymmetric vibration patterns to generate a virtual traction force which the user must respond to and turn in that direction voluntarily; this is based on the same underlying principle as Traxion \cite{rekimoto_traxion}.

*** Interactive EMS Systems
    EMS has been around for over half a century. It is mainly used for medical applications. Over several years HCI community has grown interest. Following are several implementations related, worth mentioning.

    EMS is a technique originated in the field of medical rehabilitation that applies electrical impulses to involuntarily contact muscle fibers; these impulses are delivered to the user’s muscles via electrodes attached to the skin \cite{Kruijff_hapticfeedback, strojnik_programmed}.

    Recently, researchers in HCI started to build interactive systems based on EMS. The Possessed Hand \cite{tamaki_possessedhand}, for example, is a guidance device that helps users learn for example how to play a new instrument. Pedestrian Cruise Control informs the user’s leg muscles when to turn \cite{pfeiffer_cruise}. In contrast, \app{} actuates muscles directly, thereby eliminates the cognitive load involved by systems that merely inform users when to turn.

    One motivation for the use of EMS in interactive system is that it allows replacing motors, thereby resulting in much smaller, even mobile form factors. Muscle-propelled force feedback, for example, uses EMS to provide directional force-feedback (left & right) in mobile gaming \cite{lopes_musclepropell}. Pose-IO is an interactive wearable system that allows for eyes-free input output with a computer system \cite{lopes_proprioceptive}. Affordance++ extends on this concept by allowing objects to actuate the user’s hand in order to make it manipulate the object properly \cite{lopes_affordance++}.


* Applications
** Overview

   This thesis presents six applications designed for \app{}. These applications all share some common building blocks are all designed to be initiated by the user on demand. The user can start interacting with \app{} using an application keyword or continue with any of the standard pen and paper activities discussed earlier. To start an interaction user takes turns with the computer, describes a domain and gets the answers later by applying the required plotting motion. Following chapter will describe these applications as walkthroughs to illustrate different interactions with \app{}.


** Wind-Tunnel Simulation

   Following walkthrough with \app{} showcases a designer analysing the aerodynamic properties of a car sketch. Walkthrough demonstrates the interaction principles of \app{} as it allows the designer to understand implications of the changes on the car form by sketching.

   User starts the interaction by selecting a domain from \app{}. This entry and the following sequence of actions contitude as input and prepares \app{} for output. In this case user writes the keyword, 'windtunnel'. \App{} processes input for pottential keywords to provide the transition. Tessarect \cite{tesser_ocr} classifies the input, later to match to a keyword in a dictionary. Windtunnel keyword is followed by the number '10', which signifies the wind speed in this context. This number configures the tunnel entry speed (in meters per second) of simulated particals. Windtunnel command optionally expects this configuration, otherwise default value is used. Input after the keyword is checked against spacial proximity, if in expected position, is sent to be classified by Tesseract.

   #+CAPTION: Start Windtunnel Application, Place Canvas
   #+NAME: fig:windtunnel1
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9716.jpg]]

   Once the keyword activates the domain, 'windtunnel, user proceeds to define the boundaries of the simulation area. As displayed in the figure [[fig:windtunnel1]] user defines this two dimentinal space with crop marks. At this stage \app{} stores windtunnel as an object with coordinates of the designated canvas. Input from Anoto Pen is further processed based on this context defined in the state. As the users sketch the car, points received from Anoto Pen are stored and contionusly processed to construct the outlines of the shape which later is used to create streamlines.

   After minimum input requirements for the windtunnel object are satistified, user can interact with the canvas to receive an output. By design \app{}'s windtunnel defines left boundry to be the entry point of the wind particals for the simulation. To plot a streamline user puts the Anoto Pen on the left of the canvas and starts pulling the arm thus the pen tip perpendicular to the entry axis. During this motion, \app{} steers the wrist of the user to plot the trajectory of the simulated particle in the windtunnel. After plotting several times starting from different locations on the vertical axis, user can see an overview of the sketch's aerodynamic behaivour through the field of streamlines. Figure [[fig:windtunnel2]] shows user plotting streamlines.

   #+CAPTION: Plotting streamlines
   #+NAME: fig:windtunnel2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9749.jpg]]

   As wintunnel object exists on a certain location of the paper, users can easily change the context by using an empty space on the paper. Moving to middle of the page and writing the keyword 'windtunnel' and wind speed followed by the crop marks, user creates another windtunnel object with the associated canvas. User continues the interaction by making a new sketch for the second car form to be simulated. In proximity of the new canvas, starting from the entry point for the second simulation area, user plots the field for the windtunnel. Figure [[fig:windtunnel3]] shows the user plotting the second  windtunnel.

   #+CAPTION: Plotting streamlines for the second car
   #+NAME: fig:windtunnel3
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9762.jpg]]

   At this point of the walkthrough user continues to investigate and make sense of the data generated by \app{}. In order to take a deeper look at a specific location on the simulation area, user inputs a windtunnel application specific command, 'crosssection' to select a data set. Figure [[fig:windtunnel4]] shows that second car's streamlines look straigher, which in return may suggest better aerodynamic performance. User writes 'crosssection' and names it 'sedan' refering to the form of the first car sketch. 'sedan' is the variable name that allows later recall. To select these variables, user draws a straight line on the streamlines just after the tail of the car, using the plotted canvas and the sketch as a reference. User repeats the same action on the second car to select another data set and names it 'hatchback' on the process. Two selected data sets are now available for further analysis.

   #+CAPTION: Capturing Data for Line Graph
   #+NAME: fig:windtunnel4
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9768.jpg]]

   To compare stored datasets, user moves to an empty space on the paper and starts a new object with the keyword 'plot' followed by the variable name that refers to the data set stored earlier, in this case 'sedan'. Plot keyword also requires an axis to be specified as target. Users define such areas with two perpendicular lines, which are classified by the backend as axis objects. The region defined by the axis lines describe the canvas area for the plot object. Similar to a manner of plotting streamlines user plots for first car. User repeats the action with the same keyword 'plot' followed by the second variable, 'hatchback'. Plot keyword expects an axis, in this case user selects an exisiting axis on the paper. By plotting two data sets on the same axis, results can be visually compared in the respective spacial context. Figure [[fig:windtunnel-captured]] shows the user plotting the windspeed at the cross section defined for each windtunnel.

   #+CAPTION: Plotting Selected Data Set
   #+NAME: fig:windtunnel-captured
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9777.jpg]]

   Walkthrough continues to demonstrate how the user dives deeper in to the generated data, to better understand the diffence between the performance of two car forms. Two tail speed plots seem to significantly differ at the negative crossing. Negative wind speeds would likely to be an indication of turbulent areas, thus could signify higher wind resistance. Figure [[fig:windtunnel5]] shows the user inputing a new keyword, 'zoom' and selecting a region using crop-marks. Selected area is assigned to a variable, in this case 'tail'. Tail is a modifier that refers to respective regions of both data sets stored earlier. With a similar fashion to plotting windspeeds, selected region is plotted again. With this interaction user takes a closer look at the area of interest on the previous analysis, result of the plot can be seen on figure [[fig:windtunnel5-1]].

   #+CAPTION: Zoom at data set
   #+NAME: fig:windtunnel5
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9785.jpg]]

   #+CAPTION: Plot Zoomed region for the first sketch
   #+NAME: fig:windtunnel5-1
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9788.jpg]]


   On the final step of the walkthrough user decides to compare drag coefficients of two bodies in the windtunnel. Drag cooefficient is an aerodynimcs concept, a unitless ratio that is used as an indication of the aerodynamic performance of body in a fluid. \App{} windtunnel application allows calculation of this value on the sketch. This example illustrates how \app{} can output scalar values and perform sense making on them. User starts of by writing 'plot drag', which is a keyword followed by a domain specific modifier. Plot drag command requires an axis and a sketch inside a windtunnel canvas. \app{} provides the user some flexibiliy on how to configure the widget. User can either write the name of the windtunnel object, as of 'plot drag sedan' or directly select the car figure from the context of the windtunnel with a pig tail on the car body. After the selection, user draws a line and annotates '0' and '1' as the minimum and maximum values of the axis, which is the last configuration \app{} reqires to make an scalar value output.

   #+CAPTION: Scale widget comparison
   #+NAME: fig:windtunnel6-1
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9794.jpg]]

   #+CAPTION: Plot second widget comparison
   #+NAME: fig:windtunnel6-2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/windtunnel/IMG_9799.jpg]]

   After the input sequence, plot widget can be used for the output. To initiate, user drags the pen starting from the point annotated as '0' up and when tip is on the right point of the scale \app{} pushes the hand perpendicular to leave a tick mark and up moving pen away from the paper. Figure [[fig:windtunnel6-1]] shows this step of the interaction. Point of the tick is proportionally mapped to the size of the axis defined and annotated on the paper. Same action is repeated for the second car as seen in figure [[fig:windtunnel6-2]], which shows the use of the same axis from the previous plot. After plotting both values, user can compare the performance of both forms based a scalar value calculated by the simulation.

   After these sequence of actions, user gains insight to aerodynamic properties of the forms put on paper as sketches, which would require complicated calculations or computer modeling otherwise.


** Other Application Scenarios
   \App{} allows users to accomplish complex sense making tasks with the help of an non intrusive backend. In order to further illustrate these capabilities following applications are implemented.

*** RC Filter

   Figure [[fig:rcfilter]] shows \app{}'s filter design application built to help implementing first-order RC filters.

   #+CAPTION: RC Filter Design
   #+NAME: fig:rcfilter
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/rcfilter.jpg]]

   Filter design application is used for understanding different filter designs by observing their frequency response. The domain is selected by writing the keyword 'RCfilter' followed by a variable name in this case 'highpass'. User further inputs required parameters as in keyword, variable sequence, as shown on figure [[fig:rcfilter]] as 'RCFILTER CAP 47\micro{}F'. After the enviroment is initilized, user plots the the frequency responce to observe the design of the RC filter. At this step user changes the variables and re-plots the response, which allows to iteratively design filters with adjusting components.

*** Solving Math Equations

    Figure [[fig:mathequations]] show how \app{} interfaces with Octave to enable user to accomplish complex mathematical problems.

   #+CAPTION: Plotting Math Functions
   #+NAME: fig:mathequations
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9697.jpg]]

   Figure [[fig:mathequations]] shows user plotting a fifth degree polynomical. Using the keyword 'F(X)=' user stores parameters of the polynomical in to the state. User later recall this variable with the 'plot' keyword, followed by axis definition

   #+CAPTION: Calculating the integral of a function
   #+NAME: fig:mathequations2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9698.jpg]]

   After the plot action, user calls 'integral' keyword, specifies the input and a target value. Which in return allows to spacially observe the output, where area under the curve reaches the target value. Figure [[fig:mathequations2]] shows the user getting the output of the 'integral' command query.

*** Forms and Menus

    \App{} allows symetric input and output using widgets drawn on paper. Following figure shows how user can setup a multiple choise menu to configure setting of the \app{} itself on paper.

   #+CAPTION: Query status of the checkbox form
   #+NAME: fig:formsandmenus
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9706.jpg]]

   Figure [[fig:formsandmenus]] demostrates a widget to configure \app{}. It displays a multiple checkbox example on top and a radio button below. Multiple checkboxes are initiated by the user with the keyword 'channel', followed by '?'. User then defines the list of possible values seperated by square brackets. After the widget is configured, user traces the horizontal axis, \app{} draws tick marks on active channels. 

   #+CAPTION: Input to a form widget
   #+NAME: fig:formsandmenus2
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/IMG_9707.jpg]]

   As mentioned earlier, this widget is symetric as user draws a cross on brake channel to activate it. Figure [[fig:formsandmenus2]] shows the input sequence. This is a simple appication of the radio button.

*** Fitting Trend Lines
 
    In Figure [[fig:formsandmenus]] illustrates the use of statistical functions with \app{}. In this example user accesses and plots a data set, further plots a trend line to better understand the set.

   #+CAPTION: Fitting Trend Lines
   #+NAME: fig:formsandmenus
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/bar_IMG_9675.jpg]]

   In fitting trend lines scenario user is exploring a dataset conserning sales arranged by months. User starts this interaction with the keyword 'barchart' followed by the variable 'sales'. Barchart requires an axis, which is defined by the user after keyword is invoked. A set of discreate values are mapped on the x-axis through the tick-marks drawn by \app{} as the user scans the axis. In this case user chooses to annotate the x-axis with the months. Muscle plotter is not outputing as the user is writing on an inactive area. When user decides to output a value, starts with a pen-down in proximity of the intersection between the peak of the tick mark and the x-axis and scans vertically, finally \app{} outputs a dash to the left followed by a pen up which signifies the column. 

   This scenario further extends as user applies 'plot' with 'linearfit' on to the barchart object. User starts dragging the pen from the starting point on to the y-axis and \App{} outputs linear regression as a line.

*** Optics Simulator

   #+CAPTION: Ray tracing simulation using convex and concave lenses.
   #+NAME: fig:optics
   #+ATTR_LaTeX: :width 132mm :float
   [[./images/otherapps/optics_IMG_9671.jpg]]

   Optics simulator allows exploring how rays of light refract in convex and concave lenses using \app{}. In Figure [[fig:optics]], user sketches a convex lens and explores how light rays refract through it. The application is initiated with writing a keyword, 'optics' followed by defining a region with cropmarks. When the user drags the pen through the lens, \app{} deviates the wrist based on the properties of the lens being simulated.


* Implementation
** Overview

   Current implementation of \app{} uses an Anoto Pen & Paper\cite{anoto} for input and a medically compliant 8-channel portable EMS simulator (from HASOMED \cite{hasomed}) for output. Tracking data from the Anoto pen is relayed through a windows machine to the python back-end running on a Mac OSX. Communication between the EMS machine and the python back end takes place through the custom serial protocol via USB. Current implementation only uses 4 channels of the EMS device. This setup can be miniaturized with a hardware similar to the one proposed in Proprioceptive Interaction \cite{lopes_proprioceptive}.

  #+CAPTION:    System Overview
  #+LABEL:      fig:muscle-plotter-overview
  #+ATTR_LaTeX: :width 110mm
  [[./images/teaser.JPG]]

   Following chapter will further describe the implementation in detail. First, the input module is going to be described, later output of the system will be detailed. Finally the back-end that orchestrates two will be extensively analyzed. Back-end system consists of  several different modules specilizing in different tasks, which will all be demostrated in detail.

** System Input
*** Tracking System

    Input to the system is handled by the Anoto Pen & Paper that acts as a precise tracker \cite{anoto}. the Anoto Paper has a patented dot pattern that encodes the location data for each point. The accuracy of the location is quite high where each millimeter encodes upto 30 unique points. The camera placed inside the pen tip scans and returns the value of the coordinates as long as the pen is pushing on to the paper. The angle of the pen influences the quality of tracking. The users are advised to hold the pen at an upright angle. This is importing using \app{} as a steady stream of observed points allows control loop to function properly. It is also important to mention that there is constant delay as the pen captures and analyses this image. This delay also has a detrimental effect on the performance of the control loop. The effect of the delay will be further be discussed later in the control loop section this chapter. In the current implementation of \app{}, there is a Windows server running the drives provided by the Anoto company, relaying data to the back-end server. The details of these drivers (from the vendor we’inspire) is confined by a non-disclosure agreement.

    #+CAPTION:    Anoto Pen and Paper
    #+LABEL:      fig:pad-placement-flexor
    #+ATTR_LaTeX: :width 90mm :float
    [[./images/flexor.jpg]]

    The communitation from Anoto Window API and the python backend is done via Open Sound Control (OSC). Each observation of the Anoto Pen is packaged and contains a location, nature of the observation ( pen up, pen down and drag) and a timestamp. Time stamp receieved is used for speed calculations. OSC packets are relayed to the python server through Ethernet. Measurements show that communication delay through ethernet is insignificant compared to constant processing delay introduced by the pen hardware.

** System output

    \App{} output is communicated throught electric muscle situmulation in to the arm of the user. Hence configuration of the pads on the arm and the machine that sends the signals are analysed under the system output section of the thesis.

*** EMS Machine

    EMS machine by HASOMED is capable of generating single pulses of stimulations up to a frequency of 400Hz. In our implementation at a given time two channels are active at most, as a result, each muscle shares the capacity. When in a generic travel mode of the control loop, each side of the arm is stimulated with 200Hz. \App{} pushes the capacity of the signal generator to achieve a feeling of continuous actuation.

    In addition to the frequency of pulses, the EMS machine allows to control the amplitude and duty cycle of each pulse. \App{} uses amplitudes ranging from 6mA to 18mA based on calibration results. Duty cycle ranges between 20\micro{}s to 500\micro{}s, which provides a very large dynamic range of modulation. \App{} mainly controls duty cycles to achieve gradients of actuations. At specific situations, the amplitude of the pulses are temporarily raised to boost actuation that will further be described in the control loop section.

*** Pad Placement

    Medical grade EMS Machine produced by HASOMED is used to stimulate the arm of the user. In the current implementation 4 channels of the machine is connected to the arm of the user. Each channel is responsible for a different axis of motion. For a right handed setup; flexor carpi radialis moves the pen left, extensor carpi radialis brevis and partially flexor digitorum moves the pen right. Flexor carpi ulnaris is used to push the pen onto the paper, which in return helps to reduce oscillations and slow down. Finally extensor carpi radialis longus lifts the pen up from the paper. Following figures [[fig:pad-placement-flexor]] and [[fig:pad-placement-extensor]] illustrate the pad placements.

    #+CAPTION:    Pad Placement - Flexor
    #+LABEL:      fig:pad-placement-flexor
    #+ATTR_LaTeX: :width 134mm :float
    [[./images/flexor.jpg]]

    #+CAPTION:    Pad Placement - Extensor
    #+LABEL:      fig:pad-placement-extensor
    #+ATTR_LaTeX: :width 134mm :float
    [[./images/extensor.jpg]]

** Back-end System

   A back-end system handles the communication of the input from the Anoto Pen to the output of the EMS machine. Output of \app{} has to be specificly adjusted according to the physiology of the user's arm, as a result back-end system implements a calibration procedure. Calibration values acquired are used to drive the control loop model, which is extensivly described in the following sections. Input from the tracker is constantly analyzed to respond based on the state of the interactions, these include state transitions and input classifications. Management of the control-loop and state-transitions with the context changes on the paper is abstracted in an API. This API allows to initiate and controls custom widgets described in this section. Finally application specific implementations are touched upon.

*** Calibration Process

    Calibration is an important aspect of current EMS applications. \App{} requires meticulus calibration to be adjusted specifically for each user, since for each user pen holding posture and arm psyhisology is unique. Values collected may need to be adjusted for long sessions as muscle fatigue and getting used to the plotting action may change the reaction of the arm to the actuations from the control loop. \App{} calibration generally takes place in three steps, with iterations and repeations if necessary, based on the skills and the comfort levels of the user. Back-end system implements several methods to make calibration observations possible, each illustrated in the following section.

**** Comfortable actuation current

     The throughput of the motion created by EMS changes dramatically based on the anathomy of the user's arm. Several factors, such as muscle size, skin thickness and hair density causes these variations. For the first step of calibration \app{} implements a script that step by step sweeps up the intensity of the milliamps applied to each side of the arm (left and right). The experimenter observes the minimum current that starts the motion and a the maximum current that results in a significant motion but still is not painfull. Duty cycles of the signals used in this step are kept at 200\micro{}S to allow finding a suitable dynamic range that can be can be used on the next step.

**** Slope gradients

     After the comfortable range of instensities for the EMS is determined, user is asked to draw straight lines along the paper in the posture required to plot with \app{}. At this calibration step, calibration script actuates user's arm with random pairs of currents on each side. The script records the resulting angle after each actuation. Figure [[fig:angle-overview-sheet]] at the end of this chapter showcases the marks on the paper after such a trial. In this case all actuations take place on the same horizontal axis for visualization purposes, however this location is random on normal trials to avoid users expecting a signal at a certain point. After a desired number of trial pairs, averages of the slopes are observed on a two dimentional visualization. Figure [[fig:angle-overview]] showcases this interface. Lighter collors correspond to smaller slops, while darker colors signifies pairs resulted in a higher slop. To conclude this step, three pairs that result in maximum variation between resulting slopes are chosen for each side. Pairs that consistently result in similar results are desired. It is easier to create jerky motions with EMS, however slow controlled actuations are harder to generate. Actuation of both sides, using both opposing muscles, allows \app{} to increase control on the wrist.

    #+CAPTION:    Sample trials on paper
    #+LABEL:      fig:angle-overview-sheet
    #+ATTR_LaTeX: :width 132mm
    [[./images/calibration/foto_scratch.jpg]]

    #+CAPTION:    Angle visualization
    #+LABEL:      fig:angle-overview
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/calibration/web-viz.png]]

**** Brake Calibration

     \App{} has two modes for brakes, following section on control loop will further detail each. Which ever mode is active, the intensity of the brake has to be adjusted for the specific user. Back-end sytem, uses an extentiation of slope-gradients calculation presented earlier to enable these adjustments. In brake calibration step, users draw lines similar to the last step, but this time after a random time after actuation brakes are initiated. \App{} and the calibration asistant observes how efficiently wrist motion stabilizes to select the most comfortable brake intensity for the user.

**** Output from Calibration

     Following table shows calibration results for three users that have participated in the user study. Values has been iteratively measured and adjusted during the calibration process.

|        | right  |         |         | left   |        |         | brake   |
|        | weak   | middle  | strong  | weak   | middle | strong  |         |
| User 1 | 70/110 | 110/180 | 120/240 | 110/70 | 190/90 | 220/110 | 180/190 |
| User 2 | 70/110 | 110/180 | 120/240 | 110/70 | 190/90 | 220/110 | 180/190 |
| User 3 | 70/110 | 110/180 | 120/240 | 110/70 | 190/90 | 220/110 | 110/130 |

*** Control Loop
    Control loop of \app{} uses a series of strategies based on the state of the user's hand motions and the target position. Possible situations and associated strategies are futher illustrated in the following section. Key principles are highlighted in the following figure [[fig:control-loop]].

    #+CAPTION:    Key Aspects of the Control Loop
    #+LABEL:      fig:control-loop
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/control-loop.png]]

**** Model of the Human Wrist

     \App{} uses a simple model of the human arm to manage the motion of the wrist. The wrist is assumed to be a level attached to two strings. When the wrist is stationary, tension on both sides are equal, hence forming an equilibrium. Wrist motion takes place when tension on one of the strings changes as described by the `equilibrium point model' \cite{schmidt_motorcontrol}. Situmulation through nerves and muscle fibers result in contractions stronger on one side of the wrist. When one side is contracted more then the opposing side, motion occurs in direction of the tenser side. As a result same target position can be reached with different configurations of contractions on opposing muscles. When the wrist position changes, the length of the muscle fibers also change, perhaps to find another equilibrium point when forces are again equal on each side again. Figure [[fig:equilibrium-point-model]] showcases this principle. Any given static position of the wrist is an equilibrium of forces caused by tension on opposing muscles. \cite{schmidt_motorcontrol}. \App{} relies on these principles to achieve the accuracy it needs as both muscles on opposing sides are sequentially situmulated in rapid successions. In other words intended position of the arm can be reached by applying different pairs of impulses to flexor and extensor muscles.  Moreover increasing the tension on both sides allow to override the tension naturally applied by the user. This observation can also be deferred from the data collection step of the slope calibration process.

     #+CAPTION:    Equilibrium point model for the User's Arm
     #+LABEL:      fig:equilibrium-point-model
     #+ATTR_LaTeX: :width 91mm :float
     [[./images/spring-mass-model.png]]

**** Targeting and travel
***** Control Cycles

      Control-loop of \app{} consists of control cycles exacuted consequtively. Each cycle makes observations and acts based on the respective state relative to the target. Figure [[fig:control-loop-fast]] illustrates consequtive decision cycles on the give curve. At a given point, when a control cycle begins expected trajectory of the pen tip is calculated keeping in mind the tranmission and processing delay of the Anoto Pen. In other words when the back-end reads the observation, the user is actually at a later point of the plot. This delay has been measured to be around 0.1s. As seen On figure [[fig:control-loop-fast]] each green dot is the calculated trajectory, where blue points represent the respective targets for that specific cycle.

     #+CAPTION:    Observed and Target Points Visualized
     #+LABEL:      fig:control-loop-fast
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/loop_in_action.png]]

***** Dynamic Adjustments

      If the user is lagging behind the target, the signal intensity applied to muscle that that causes the delay is increased by 1 mA. The lag is constantly stored on each control cycle. When the cummulative lag in previous cycles is above 0.6mm, boost is applied. Moreoever if the next cycle still lags above the 0.6mm threshold, the boost is increased 2 mA. Such an increase causes the arm to respond faster then the duty cycle changes using in the normal mode. This adjustment can be considered as the integral part of a classical PID controller.  

***** Modes of Braking

      As mentioned earlier \app{} uses two modes of braking strategies. What ever the strategy is brakes are activated at same certain situations during the control loop. At the observation and estimation state, \app{} calculates the expected location and later the expected trajectory. If this trajectrory:
 - is pointing torwards the target
 - the user has been away from the target for a certain distance
 - and expected trajectory is is measured to have an intersection with the target
brakes are activated. This mode can be considered as the derivation component of a traditional PID controller. Main aim is to reduce the oscillations occuring while the plotting takes place. Figure [[fig:control-loop]] shows the brake activation cycles with cyan circles on the top curve. Buttom curve showcases observed and target points as in the previous figure. Following sections will identify two modes of braking.

     #+CAPTION:    Brakes applied during the plot 
     #+LABEL:      fig:control-loop
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/crazy_fast.png]]

****** Tensing Up both sides

       First braking strategy is based on the two channel implementation of \app{}. This mode has been used in the user study, while the findings pointed torwards a better implementation described in the next subsection. This strategy uses high intensity pulses on each side of the arm to achive and equilibrium point at a neutral angle. As mentioned in the [[*Model of the human wrist][model of the human wrist]] section, high instensities on both sides override previous motions to reach an neutral position. However observations during the study showed that this created a confusion for the users when in combination with them momentum of the plotting action itself, as they were confused with such impulses expecting a resulting motion on either sides.

****** Additional channel pushing down
       
       Second mode of braking uses an additional channel thrusting towards the paper, as mentioned in the pad placement section. This enables \app{} to utilize the power of arm muscles that are not activated by the steering motion. As a result the intent of the system is also percieved more clearly avoiding confusions.

**** Ending an interaction

     Control loop also implements a feature to signify when a plot is over. This consists of a strong single pulse in the direction away from the paper. When a certain position is reached, \app{} issues pen-up command, which in return lifts the arm away from the paper.


*** Higher level API for Flow Control

    \App{} interactions are implemented in the form of a widget. These widgets leverage pen-input techniques such as crossing to select 1D primitives (CrossY \cite{Apitz_crossy}), underline and crop marks (Papiercraft \cite{liao_papiercraft}), and a pigtail gesture to select 2D primitives (Scriboli \cite{Hinckley_delemiters}). All widgets output when the user crosses into its’ boundaries on the paper context. The output ends when \app{} stimulates the muscles that cause the user to lift the pen’s tip from the paper.

   Canvas elements enable the user to control the flow and structure of \app{}'s output. We have designed several widgets for different data structures. Scalar values are represented on a line, they consist of a single axis. Functions are represented in a two dimensional area, as they exist on two axes. These widgets on paper, what ever the underlying data structure is, have some characteristics in common. All the canvas elements define an actual space on the paper with designated areas for interaction. These elements have essentials to be initialized, as well as optional modifications to shape and control the output. These widgets determine where electronic muscle stimulation is going to active, which in return serves as starting point for the plots. In the following chapter, we introduce the widgets based on their underlying data structure, describing the methods of initiation and use. All elements are drawn onto the paper, it is important to remind that they persist in an inactive state even when the user is working on an other part of the paper. They can be reused with appropriate commands.

**** Single axis elements

    These widgets are designed to output scalar values that are projected onto a line. Resulting value is represented in spacial reference to the domain of the axis draw for the widget. These can be used for the output of a single class as well as to compare different classes in the same domain. Output domain can range between Boolean to real numbers. Limitations imposed by \app{} determines the sense making possibilities and the fidelity of the output. We have some design principles that allows the user to modify the axis to achieve reasonable outputs.

    To initiate a single axis element, after writing the designated command to initiate, user draws a line in any orientation on the paper. By default, south-west facing edge of the line is assigned to the minimum value, while north-east facing edge is assigned to the maximum value. If the minimum and maximum values are not defined in the next optional step, default values for the specific domain is used. For example 0 to 1 in drag coefficient comparison, or the x value of the maximum of a plot would be projected on to the domain represented by the plot itself in maximum analysis of a function. The axis can be scaled by the user simply by annotating the maximum and/or the minimum value.

    After all the essentials are placed on the paper, the scale component is ready to use. It starts of by user placing the tip of the pen at the beginning of the scale. If the pen lands in the accepted proximity of the origin, ems channels on both sides (left and right presented earlier) of the arm are activated at a tactile feedback level that doesn't actuate the user. This output only signifies that an output interaction is taking place. At this point, user starts dragging the pen keeping the tip on the paper to the end of the axis line. The back-end system, tracks user's motion and triggers a quick nudge followed by a pulse on the upper channel. This gesture leaves a visible trace behind on the axis, where desired value is projected on the the axis on the paper. The user can observe and annotate the value, as the widget is not active after a successful output procedure.

***** Scale Widget 
      The scale widget outputs a single value per interaction, useful for comparing values. In case of clus- tered values in the same scale, muscle-plotter will output them by alternating the tick-marks to the left/right. In the walkthrough and scenarios, we featured the scale widget in: finding the drag-coefficient, finding an integral of a func- tion and plotting individual bars in a chart. Just as with the axes of a plot, the scale widget allows to redefine its axis for zoom in/out.

***** Radio button
      The radio button allows selecting one option out of a range or receiving output from one option, which is active. This can also be used for a yes/no dialog, useful when asking simple yes/no questions to muscle-plotter (e.g., to check if a number is prime). In the examples above, we demonstrated this widget at the example of a user configuring the intensity of an EMS channel.

***** Checkbox
      The checkbox is an extension of the radio button that allows for multiple choices to be active. This widget is useful for finding elements in lists such as options in a combo box. We demonstrated at the example of a user querying which EMS channels are currently active.

**** Double axis elements - Parametric values / functions

    Double axis elements have a major and a minor axis. The user drags the pen along the major axis, while the system takes the tip of the pen to the value corresponding on the minor axis with respect to the specific location on the major axis.

     #+CAPTION:    A Windtunnel Object
     #+LABEL:      fig:windtunnel-roto
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/canvas-rotoscope-01.png]]

    As we have presented on the walk-through, our main contribution comes from the spatial expressivity of plotting one-to-functions, such as streamlines of the wind-tunnel or the speed values for a defined cross-section. For both use cases the space defined on the paper is same in nature, while the tools to define are domain dependent. In the wind-tunnel case, there exists a line for every point on the vertical start axis as stream lines result from a single solution of a vector field. On the other hand for the speed values line example, there exists one unique line, that the user can plot.

    In order to initiate a multiple axis plot, the user has to define a space on the paper. This is done by drawing two perpendicular lines representing the axes or crop-marks that encompasses the area. In case of a function plot, after defining axis lines user can optionally update the domain. Otherwise, defaults for the specific example is used just as defined in single axis examples.

     #+CAPTION:    A Generic Canvas with Axes
     #+LABEL:      fig:axis-roto
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/axis-rotoscope-01.png]]
   
    In a similar fashion to scales, the user should start at a specific position to instantiate the plotting procedure. In a generic plot, the output can be located in different quadrants. We have defined a method for the user to locate it to start plotting. Following interactions to find plot starting points are similar in nature to the scalar interactions described above. In the first case, where there is a zero crossing on the negative side of the major axis, user places the tip of the pen to the far left (negative, west) of the horizontal, major, dragging axis. The paper should have been rotated to a comfortable angle for a convenient plot. Then the user follows the axis, when zero crossing is reached, \app{} takes over the control of the arm to output the rest of the plot. If necessary, the user can rotate the paper 180 degrees and plot the negative side of the desired line.

    In the case of in the case of no zero crossing before the origin, \app{} signals a pen-up before first scanning starts. At this point the user knows that there isn't a zero crossing between 3rd and 4th quadrants. The step  user should do is to scan the y axis, to find any y-crossings. Ideally user starts from the minimum point of the minor axis and drags the tip of the pen to the maximum point of the axis. If there is a y-crossing of the plot, \app{} assigns a pen-down on the target location. From this point on the user follows parallel to the major axis to continue as a normal plot. The negative side of the function can be plotted by rotating the paper in a similar manner to the first case.

     #+CAPTION:    Finding the starting Point
     #+LABEL:      fig:axis-start
     #+ATTR_LaTeX: :width 132mm :float
     [[./images/implementation/axis-rotoscope-02.png]]

    In the last case, when there is no zero crossing between 3rd and 4h quadrants and there is no y-axis intersection, the second axis find attempt of the user is interrupted by a pen-up as the tip of the pen is place on the minor-axis, (y-axis). The users follows over the major axis to find the crossing there. \app{} takes over control as the crossing is reached. The plot can be completed in a similar manner by rotating it as described in previous cases.

***** Line chart
      The walkthrough contained 3 specialized in- stances of the line chart widget, i.e., wind tunnel, the tail profile plots and the zoomed plots. The line chart widget supports the following interactions: zoom in/out by relabel- ing the axes, zoom in by selecting with crop marks, fitting a line through existing data points, performing operations on data traces and re-plotting the results as a trace (e.g., deriv- ative of a function. The line chart widget affords zoom- in/out by relabeling the axes of the plot.


*** Recognition System

**** Handwriting Recognition using Tesseract

     To recognize hand-written input we integrated Tesseract \cite{tesser_ocr}, a trained recognizer with several languages and likely the most robust open-source OCR \cite{compar_open_sourc_ocr}. In Tesseract \app{} only loads the English language and common symbols such as “?”, “(“, etc. Before executing Tesseract on the user’s strokes we: (1) append all strokes that are less than 3mm apart from their center to form a character (enables multi-stroke writing). (2) Interpolate the points from Anoto to complete a line based on pen up and downs. (3) Convert to a black and white image for OCR. (4) If the next stroke is more than 1cm apart, the previous strokes are grouped into a command keyword and evaluated with the OCR. (5) After a command keyword is detected \app{} evaluates the incoming strokes character by character, this allows to directly write commands such as “PLOT F(X)=SIN(X)”.

     Once the output of Tesseract is returned to muscle-plotter, we find the closest word using the Levenshtein distance (edit distance). We do so because many characters tend to create false positives with Tesseract, such as “L” and “(“ or “X” and “K”). Thus, when Tesseract recognizes “P(OT” instead of “PLOT”, muscle-plotter recognizes it from our set of keywords, since the Levenshtein-distance is 1 (i.e., by replacing one character we find a positive match). We allow a maximum edit-distance of a third the input word’s length (rounded down).


*** Application Specific Implementations
**** Mathematical Applications
     To solve the mathematical formulae we invoke Octave through its Py- thon bindings. We use it for mathematics (derivatives, integrals, and so forth) and for plotting functions from formulae. We interface muscle-plotter and Octave by: (1) converting user-notation to Octave notation – when the user writes “sin(x)” we convert it to “feval((sin(x), range-of- plot)”; then, (2) send the formulae to Octave, sample it into points and return it to muscle-plotter; and, lastly, (3) transform these points to the Anoto paper’s coordinates and into the user-defined axis.

**** RC Filter Response
     We implemented a simple solver for high and low pass RC circuit filters. It works by solving the filter equations directly in the frequency domain. The val- ues for R and C are read from the users’ input when they write down “cap 10UF” (i.e., 10μF) and “resistor 330” (in Ohms).

**** Statistic Applications
     To perform statistics operations we utilize the Python’s Scipy Stats package. This allows us to invoke operations such as computing a standard deviation or a regression, which was demonstrated at the example of a linear regression through the bar chart data.

**** Optical Ray Casting
     The optics demonstration is a simple 2D ray casting based on \cite{thin_python} that deals exclusively with concave and convex lenses. The lenses focal points are simply proportional to the width of the drawn lenses bounding box.

**** Wind-tunnel Simulation
     The wind tunnel simulation is based on the Lattice-Boltzmann equations and adapted from Schroeder’s implementation \cite{lattic_boltz_simul_fluid}. To run a wind-tunnel simulation (i.e., to compute the wind speed streamlines) we: (1) rotate the model accordingly to the rotation of the wind-tunnel boundaries; (2) extract the shapes drawn in- side; (3) down-sample these shapes (e.g., the car) into a binary matrix of 200px height; this matrix contains the obstacles to the wind flow; (4) for 30 steps we execute the Lattice Boltzmann by always moving the wind-lines one more step and re-evaluating the collisions to compute the velocity flow; (5) once the user draws a line to get the wind streamline as output, we use Matplotlib’s streamlines function to obtain the streamline as a curve from the user’s pen down position.


* User Study
  A user study has been conducted to understand spacial output production capabilities of \app{}. Participants repeatedly plotted curves using \app{}, later target curves were compared to actuals on paper.

** Study design

*** Task
    For each trial, participants plotted one function onto paper using \app{} as displayed in figure [[fig:user-study-1]]. Participants were instructed to place the pen tip hence their hands on a starting marker to the left side of the paper. Later they draged their hands towards the right side of the page, at a comfortable speed they desired. While dragging, \app{} has actuated the wrist to plot the target.

    #+CAPTION:    User Plotting
    #+LABEL:      fig:user-study-1
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/setup.png]]
   
    Each trial lasted for 16 centimeters from left to right. For each trial, target and measured points were recorded, as well as the duration pen tip was in contact with the paper. Eight targets randomly served to participants are shown in figure [[fig:target-functions]]. First six functions labeled as Sin1 to Sin6 were composed by adding offphased sine waves of increasing frequency up to 0.5 cycles/cm. Remaining two functions consist of a triangular wave (denoted as Tri) and a half sine wave followed by a flat section (denoted as Flat). These two functions aim to explore how the system behaves with regards to abrupt changes in slope and curvature as well as to prevent participants from getting used to sine wave patterns.

    As every participant performed each function twice, total of 128 trials (8 functions x 2 repetitions x 8 participants) have been conducted.

*** Aparatus

    #+CAPTION:    User Plotting
    #+LABEL:      fig:aparatus-1
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/closeup.png]]

    Figure [[fig:aparatus-1]] shows apparatus for the user study. Participants wore \app{}’s electrodes on the wrist flexor and extensor muscles as described in [[*Pad Placement][pad placement section]]. Participants were seated with the dominant forearm rested on the table to reduce fatigue. Plots were made using the controller described in Implementation, which actuated flexors and extensors simultaneously but without brake channel, which was introduced as an outcome of this study. Brake effect was achieve via tensing both sides. During the \app{} software administered the respective functions to the user; all other functionality was disabled.

*** Participants

    8 participants were recruited (1 female), between 22 and 26 years old (M = 23.9 years) from the local university. With consent of the participants trials were videotaped. Participants calibrated with the procedure described in Implementation section.


** Study Results
   Raw data measured in Figure [[fig:target-functions]] shows all the curves drawn by each participant. The average error from respective targets across all 128 trials was 4.07 mm (SD=3.03 mm).

    #+CAPTION:    Target Functions
    #+LABEL:      fig:target-functions
    #+ATTR_LaTeX: :width 152mm :float
    [[./images/studyresults/figure_1.png]]

*** Preservation of sine-based functions

    Figure [[fig:target-functions]] also shows the average error per by function. As expected, there was an increase in error with the increase in the function’s highest frequency (Sin1: M=2.45 mm, SD = 1.42 mm; Sin2: M= 2.65 mm, SD=1.29 mm; Sin3: M=2.66 mm, SD=0.90 mm; Sin4: M=3.15 mm, SD=1.00 mm; Sin5: M=4.55 mm, SD=1.31 mm; Sin6: M=10.06, SD=2.67 mm), confirmed by a linear regression through Sin1-Sin6 with R2=0.64. To provide an estimation of how much each trial differed to the next, the reported standard deviations (SD) are between the averages for all trials.

*** Preservation of non-sine functions

    When plotting the two functions that contained abrupt changes in slope and curvature participants performed similarly to the sine waves (Tri: M=4.77 mm, SD=1.53 mm; and, Flat: M=2.29 mm, SD=0.82 mm).

*** Preservation of features
    
    The plots in Figure [[fig:frequency-analysis]] illustrate in how far plots made through muscle-plotter preserved the original function. The plots show frequency histograms produced by means of Fourier Transformation. We see the original signal in green, as well as user-specific jitter—aka noise, in red. As the plots illustrate, jitter tends to revolve around wavelengths smaller than 0.5 cycles/cm.

    #+CAPTION:    Frequency Analysis
    #+LABEL:      fig:frequency-analysis
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/fft_2.png]]

    Jitter in Sin2 and Sin3 has very little impact on the signal (the same as observed in Sin1 and Sin4). This gets more challenging with Sin5, which has its highest partial at a wavelength of around 0.23 cycles/cm. Still, signal and jitter are clearly distinct, which means that the original function still stands out clearly, so that awareness of one’s jitter allows users to visually filter out the noise. The distance between signal and jitter gets smaller with increasing signal frequency until they start to overlap in Sin6, suggesting that part of this signal has drowned in the noise and thus has become unrecognizable.

    We conclude that muscle-plotter is suitable for reproducing signals of up to 0.3 cycles/cm wavelengths, but should not be used for frequencies higher than this.

*** Speed/Accuracy tradeoff

    The fact that participants picked their own pace resulted in a wide range of speeds. Partici- pants plotted the 16 cm-wide functions in between 7.98 s and 29.5 s (M=16.17 s, SD=4.90 s). Figure 17 illustrates the resulting speed/accuracy tradeoff. We observed a de- crease in accuracy when the plots were under 11 s and shows a steady accuracy around the average error of 4.07 mm for plots that took over 11 s.

    #+CAPTION:    Frequency Analysis
    #+LABEL:      fig:frequency-analysis
    #+ATTR_LaTeX: :width 132mm :float
    [[./images/studyresults/Fig5.png]]

* Discussion

** Drawing vs. Steering
   Working principles of \app{} limits drawing capabilities to a single axis, which can't be considered as a 2D drawing activity. More complicated data is plotted with repating the same motion in different spacial contexts as seen in streamlines of the windtunnel. Plotting with \app{} is based on a steering motion as pen draws a curve. Exanding these limitations to a two dimentinal surface would require coordination of multiple muscles on the human body, arm, and wrist. Controling such a complex motion with EMS would require extensive control over each possible channel, perhaps with some levels of abstraction. 

** Considering User study
   \App{} is a novel interface that has different limitations and strenghts compared to traditional gui based systems. User study we have introduced tries to understand the plotting capabilities of the system, to better understand applications possible. However usability of those applications are left out from the user study.

** Design Considerations
   Based on the findings of designing applications for \app{}, this theses points to a couple of principles that are important to consider to create usable applications.
   
*** Discoverability
    \App{} provides an interactive environment using user initiated components on paper. This approach differs from previous interactive systems as the user is expected to have a prior knowledge of the provided language. In many cases our interactions start with an empty sheet of paper. On the other hand screen based interactive systems provide discoverability as the system itself has a wider channel for output, such applications can start with a tutorial expecting the user to have zero prior knowledge. Designing applications for \app{} should consider this to provide an engaging experience. According to the domain of the application, command keywords could be flexible and adaptive, moreover similar to a natural language.

*** Interactive Text Books
    \app{} interactions require some input from the user side, in order to determine the domain and configure the output. In the simplest case, user has to acomplish a sequence of inputs to get a the first output. Predesigned worksheets would allow to simplify these steps, minimizing the learning curve as well as creating engaging interactions. Figure [[fig:optics-worksheet]] shows a sample prepared for testing. Combination of such examples could make upto interactive textbooks.

    #+CAPTION:    Optics Worksheet Example
    #+LABEL:      fig:optics-worksheet
    #+ATTR_LaTeX: :width 110mm
    [[./images/discussion/optics_ex1.png]]

    #+CAPTION:    Optics Worksheet Example 2
    #+LABEL:      fig:optics-worksheet2
    #+ATTR_LaTeX: :width 110mm
    [[./images/discussion/optics_ex2.png]]

*** User Feedback
    Usabilty theory for interactive systems inform the user about the state of the world. \App{} is able to provide positive and negative feedback in a non intrusive way with distinct gestures. Interactions with \app{} should make use of feedback messages, in order to provide the user with an awareness of the state of system. As the interactions happen on a piece of paper, certain locations marked by the user, should behave in a consistent way. The user can approach a plot for several actions, such as actual plotting, zooming into a certain section, re-labeling the axis or selecting a region for further analysis.

*** Widget size and expected error
    \App{} has a limited accuracy due to the limitations of EMS. Interactive elements on paper should be scaled at a size greater that leaves the expected error insignificant. For example, a continuous scale described previously should verify that the output will provide a significant answer.

*** Output Persistence and clutter on paper
    The output of \app{} is persistent on paper. When the user draws a certain plot on a given axis, the output stays on the paper way longer then the length of the interaction. In an example of function plotting if the outputs were made and their essential characteristics are not different enough, the answers can be mixed up. As a solution, the user has the flexibility to annotate the output. This would allow the number of distinct traces that can be recalled later on. However, after a certain number of plots, the intelligibility would diminish. This is an inherent problem with writing on the paper, where the user would extend to the empty space below or to the next page. \App{} widgets are reusable, however they are also easy to initiate.


* Conclusion

  This thesis presented \app{}, an interactive system based on electrical muscle stimulation that offers more meaningful and expressive output. It is designed to assist users in cognitively demanding activities, such as designing an aerodynamically sound vehicle, by providing them with access to a computer system while they are sketching on pen and paper.

  Muscle-plotter provides pen-on-paper interactions for both input and output. To interact, users input by writing, e.g., writing mathematical formulas or drawing shapes. The system outputs by actuating the user’s wrist so as to draw graphs, strokes, etc. In the thesis six simple applications have been demonstrated, including a wind-tunnel simulator, and RC circuit simulator, function plotting, as well as a set of generic widgets. To validate the accuracy wrist-actuation system, a user study has been conducted and presented.

** Future Work
*** Evaluate applications

    This thesis approaches the user study in terms of understanding the accuracy and plotting capabilities of \app{}. The accuracy of the system should be considered when designing applications. Quality and the usability of the data outputed for application specific domains can be investigated.

    As mentioned in the discussion \app{} preserves low frequencies while adding relatively small amounts of noise to higher spectrum. The cognitive capabilities of human brain remains as a question as it is unknown when added noise would totally hide away the intended answer. As mentioned usability of \app{} output can be further studied in a broder perspective.
    
*** Improve recognition

    \App{} uses tesseract for character and keyword recognition. Tesseract is an excellent solution for optical character recognition, however hand-writing is a better task for classification using deep learning. Recent develelopments make it relatively easier to implement such a recognition system, which in return would significantly improve recognition performance of \app{}. Such an improvement would make more usable applications possible.


#+LATEX: \backmatter{}
#+LATEX: \newpage{}
#+LATEX: \printbibliography{}

